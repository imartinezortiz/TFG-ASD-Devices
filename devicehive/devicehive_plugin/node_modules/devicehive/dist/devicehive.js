(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
window.DeviceHive = require('./src/DeviceHive');

},{"./src/DeviceHive":21}],2:[function(require,module,exports){
'use strict';
var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp(token, 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');

function decodeComponents(components, split) {
	try {
		// Try to decode the entire string first
		return decodeURIComponent(components.join(''));
	} catch (err) {
		// Do nothing
	}

	if (components.length === 1) {
		return components;
	}

	split = split || 1;

	// Split the array in 2 parts
	var left = components.slice(0, split);
	var right = components.slice(split);

	return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}

function decode(input) {
	try {
		return decodeURIComponent(input);
	} catch (err) {
		var tokens = input.match(singleMatcher);

		for (var i = 1; i < tokens.length; i++) {
			input = decodeComponents(tokens, i).join('');

			tokens = input.match(singleMatcher);
		}

		return input;
	}
}

function customDecodeURIComponent(input) {
	// Keep track of all the replacements and prefill the map with the `BOM`
	var replaceMap = {
		'%FE%FF': '\uFFFD\uFFFD',
		'%FF%FE': '\uFFFD\uFFFD'
	};

	var match = multiMatcher.exec(input);
	while (match) {
		try {
			// Decode as big chunks as possible
			replaceMap[match[0]] = decodeURIComponent(match[0]);
		} catch (err) {
			var result = decode(match[0]);

			if (result !== match[0]) {
				replaceMap[match[0]] = result;
			}
		}

		match = multiMatcher.exec(input);
	}

	// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
	replaceMap['%C2'] = '\uFFFD';

	var entries = Object.keys(replaceMap);

	for (var i = 0; i < entries.length; i++) {
		// Replace all decoded components
		var key = entries[i];
		input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
	}

	return input;
}

module.exports = function (encodedURI) {
	if (typeof encodedURI !== 'string') {
		throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
	}

	try {
		encodedURI = encodedURI.replace(/\+/g, ' ');

		// Try the built in decoder first
		return decodeURIComponent(encodedURI);
	} catch (err) {
		// Fallback to a more advanced decoder
		return customDecodeURIComponent(encodedURI);
	}
};

},{}],3:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],4:[function(require,module,exports){
// the whatwg-fetch polyfill installs the fetch() function
// on the global object (window or self)
//
// Return that as the export for use in Webpack, Browserify etc.
require('whatwg-fetch');
module.exports = self.fetch.bind(self);

},{"whatwg-fetch":19}],5:[function(require,module,exports){
/**
 * The code was extracted from:
 * https://github.com/davidchambers/Base64.js
 */

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function InvalidCharacterError(message) {
  this.message = message;
}

InvalidCharacterError.prototype = new Error();
InvalidCharacterError.prototype.name = 'InvalidCharacterError';

function polyfill (input) {
  var str = String(input).replace(/=+$/, '');
  if (str.length % 4 == 1) {
    throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
  }
  for (
    // initialize result and counters
    var bc = 0, bs, buffer, idx = 0, output = '';
    // get next character
    buffer = str.charAt(idx++);
    // character found in table? initialize bit storage and add its ascii value;
    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
      // and if not first of each 4 characters,
      // convert the first 8 bits to one ascii character
      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
  ) {
    // try to find character in table (0-63, not found => -1)
    buffer = chars.indexOf(buffer);
  }
  return output;
}


module.exports = typeof window !== 'undefined' && window.atob && window.atob.bind(window) || polyfill;

},{}],6:[function(require,module,exports){
var atob = require('./atob');

function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).replace(/(.)/g, function (m, p) {
    var code = p.charCodeAt(0).toString(16).toUpperCase();
    if (code.length < 2) {
      code = '0' + code;
    }
    return '%' + code;
  }));
}

module.exports = function(str) {
  var output = str.replace(/-/g, "+").replace(/_/g, "/");
  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += "==";
      break;
    case 3:
      output += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }

  try{
    return b64DecodeUnicode(output);
  } catch (err) {
    return atob(output);
  }
};

},{"./atob":5}],7:[function(require,module,exports){
'use strict';

var base64_url_decode = require('./base64_url_decode');

function InvalidTokenError(message) {
  this.message = message;
}

InvalidTokenError.prototype = new Error();
InvalidTokenError.prototype.name = 'InvalidTokenError';

module.exports = function (token,options) {
  if (typeof token !== 'string') {
    throw new InvalidTokenError('Invalid token specified');
  }

  options = options || {};
  var pos = options.header === true ? 0 : 1;
  try {
    return JSON.parse(base64_url_decode(token.split('.')[pos]));
  } catch (e) {
    throw new InvalidTokenError('Invalid token specified: ' + e.message);
  }
};

module.exports.InvalidTokenError = InvalidTokenError;

},{"./base64_url_decode":6}],8:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],9:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],10:[function(require,module,exports){
'use strict';
var strictUriEncode = require('strict-uri-encode');
var objectAssign = require('object-assign');
var decodeComponent = require('decode-uri-component');

function encoderForArrayFormat(opts) {
	switch (opts.arrayFormat) {
		case 'index':
			return function (key, value, index) {
				return value === null ? [
					encode(key, opts),
					'[',
					index,
					']'
				].join('') : [
					encode(key, opts),
					'[',
					encode(index, opts),
					']=',
					encode(value, opts)
				].join('');
			};

		case 'bracket':
			return function (key, value) {
				return value === null ? encode(key, opts) : [
					encode(key, opts),
					'[]=',
					encode(value, opts)
				].join('');
			};

		default:
			return function (key, value) {
				return value === null ? encode(key, opts) : [
					encode(key, opts),
					'=',
					encode(value, opts)
				].join('');
			};
	}
}

function parserForArrayFormat(opts) {
	var result;

	switch (opts.arrayFormat) {
		case 'index':
			return function (key, value, accumulator) {
				result = /\[(\d*)\]$/.exec(key);

				key = key.replace(/\[\d*\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				}

				if (accumulator[key] === undefined) {
					accumulator[key] = {};
				}

				accumulator[key][result[1]] = value;
			};

		case 'bracket':
			return function (key, value, accumulator) {
				result = /(\[\])$/.exec(key);
				key = key.replace(/\[\]$/, '');

				if (!result) {
					accumulator[key] = value;
					return;
				} else if (accumulator[key] === undefined) {
					accumulator[key] = [value];
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};

		default:
			return function (key, value, accumulator) {
				if (accumulator[key] === undefined) {
					accumulator[key] = value;
					return;
				}

				accumulator[key] = [].concat(accumulator[key], value);
			};
	}
}

function encode(value, opts) {
	if (opts.encode) {
		return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
	}

	return value;
}

function keysSorter(input) {
	if (Array.isArray(input)) {
		return input.sort();
	} else if (typeof input === 'object') {
		return keysSorter(Object.keys(input)).sort(function (a, b) {
			return Number(a) - Number(b);
		}).map(function (key) {
			return input[key];
		});
	}

	return input;
}

function extract(str) {
	var queryStart = str.indexOf('?');
	if (queryStart === -1) {
		return '';
	}
	return str.slice(queryStart + 1);
}

function parse(str, opts) {
	opts = objectAssign({arrayFormat: 'none'}, opts);

	var formatter = parserForArrayFormat(opts);

	// Create an object with no prototype
	// https://github.com/sindresorhus/query-string/issues/47
	var ret = Object.create(null);

	if (typeof str !== 'string') {
		return ret;
	}

	str = str.trim().replace(/^[?#&]/, '');

	if (!str) {
		return ret;
	}

	str.split('&').forEach(function (param) {
		var parts = param.replace(/\+/g, ' ').split('=');
		// Firefox (pre 40) decodes `%3D` to `=`
		// https://github.com/sindresorhus/query-string/pull/37
		var key = parts.shift();
		var val = parts.length > 0 ? parts.join('=') : undefined;

		// missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		val = val === undefined ? null : decodeComponent(val);

		formatter(decodeComponent(key), val, ret);
	});

	return Object.keys(ret).sort().reduce(function (result, key) {
		var val = ret[key];
		if (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {
			// Sort object keys, not values
			result[key] = keysSorter(val);
		} else {
			result[key] = val;
		}

		return result;
	}, Object.create(null));
}

exports.extract = extract;
exports.parse = parse;

exports.stringify = function (obj, opts) {
	var defaults = {
		encode: true,
		strict: true,
		arrayFormat: 'none'
	};

	opts = objectAssign(defaults, opts);

	if (opts.sort === false) {
		opts.sort = function () {};
	}

	var formatter = encoderForArrayFormat(opts);

	return obj ? Object.keys(obj).sort(opts.sort).map(function (key) {
		var val = obj[key];

		if (val === undefined) {
			return '';
		}

		if (val === null) {
			return encode(key, opts);
		}

		if (Array.isArray(val)) {
			var result = [];

			val.slice().forEach(function (val2) {
				if (val2 === undefined) {
					return;
				}

				result.push(formatter(key, val2, result.length));
			});

			return result.join('&');
		}

		return encode(key, opts) + '=' + encode(val, opts);
	}).filter(function (x) {
		return x.length > 0;
	}).join('&') : '';
};

exports.parseUrl = function (str, opts) {
	return {
		url: str.split('?')[0] || '',
		query: parse(extract(str), opts)
	};
};

},{"decode-uri-component":2,"object-assign":8,"strict-uri-encode":14}],11:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],12:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],13:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":11,"./encode":12}],14:[function(require,module,exports){
'use strict';
module.exports = function (str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
	});
};

},{}],15:[function(require,module,exports){
var nargs = /\{([0-9a-zA-Z_]+)\}/g

module.exports = template

function template(string) {
    var args

    if (arguments.length === 2 && typeof arguments[1] === "object") {
        args = arguments[1]
    } else {
        args = new Array(arguments.length - 1)
        for (var i = 1; i < arguments.length; ++i) {
            args[i - 1] = arguments[i]
        }
    }

    if (!args || !args.hasOwnProperty) {
        args = {}
    }

    return string.replace(nargs, function replaceArg(match, i, index) {
        var result

        if (string[index - 1] === "{" &&
            string[index + match.length] === "}") {
            return i
        } else {
            result = args.hasOwnProperty(i) ? args[i] : null
            if (result === null || result === undefined) {
                return ""
            }

            return result
        }
    })
}

},{}],16:[function(require,module,exports){
'use strict';

module.exports = WebSocket;

},{}],17:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":18,"punycode":9,"querystring":13}],18:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],19:[function(require,module,exports){
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ]

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1])
      }, this)
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var oldValue = this.map[name]
    this.map[name] = oldValue ? oldValue+','+value : value
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    name = normalizeName(name)
    return this.has(name) ? this.map[name] : null
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value)
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this)
      }
    }
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsArrayBuffer(blob)
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsText(blob)
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf)
    var chars = new Array(view.length)

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i])
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength)
      view.set(new Uint8Array(buf))
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (!body) {
        this._bodyText = ''
      } else if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer)
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer])
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body)
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      }
    }

    this.text = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body && input._bodyInit != null) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = String(input)
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers()
    rawHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
    return headers
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = 'status' in options ? options.status : 200
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = 'statusText' in options ? options.statusText : 'OK'
    this.headers = new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

},{}],20:[function(require,module,exports){
const EventEmitter = require('events');
const Transport = require('./transports/base/Transport');
const HTTP = require('./transports/HTTP');
const WS = require('./transports/WS');
const API = require(`./controllers/API`);
const ApiMap = require(`./controllers/transportResolvers/ApiMap`);
const Utils = require('./utils/Utils');
const UnsupportedTransportError = require('./error/UnsupportedTransportError');

/**
 * ApiStrategy. This class handles all transport specific moments
 * @event message
 * @event error
*/
class ApiStrategy extends EventEmitter {

    static get MESSAGE_EVENT() {
        return Transport.MESSAGE_EVENT;
    }
    static get ERROR_EVENT() {
        return Transport.ERROR_EVENT;
    }

    /**
     * Returns transport by url
     * @param url
     * @returns Transport Class
     */
    static getTransport(url) {
        if (url.startsWith(HTTP.TYPE)) {
            return HTTP;
        } else if (url.startsWith(WS.TYPE)) {
            return WS;
        } else {
            throw new UnsupportedTransportError();
        }
    }

    /**
     * Creates ApiStrategy
     * @param {object} urls ({ mainServiceURL, authServiceURL, pluginServiceURL })
     */
    constructor({ mainServiceURL, authServiceURL, pluginServiceURL }) {
        super();

        const me = this;

        me.subscriptionMap = new Map();
        me.subscriptionIdsMap = new Map();
        me.subscriptionLastTimestampMap = new Map();
        me.reconnectionHandler = null;
        me.reAuthorizationHandler = null;

        me.urlsMap = new Map();

        me.urlsMap.set(API.MAIN_BASE, mainServiceURL);
        me.urlsMap.set(API.AUTH_BASE, authServiceURL);
        me.urlsMap.set(API.PLUGIN_BASE, pluginServiceURL);

        me.transport = new (ApiStrategy.getTransport(mainServiceURL))({ url: mainServiceURL });

        me._initTransportSpecificFunctionality();

        me.transport.on(Transport.MESSAGE_EVENT, message => {
            switch (me.transport.type) {
                case HTTP.TYPE:
                    if (message.subscriptionId) {
                        message.subscriptionId = me._internalSubscriptionIdToExternal(message.subscriptionId);
                    }

                    if (message.subscriptionId && message.timestamp) {
                        me.subscriptionLastTimestampMap.set(message.subscriptionId, message.timestamp);
                    }

                    me.emit(ApiStrategy.MESSAGE_EVENT, message);
                    break;
                case WS.TYPE:
                    if (message.subscriptionId && message.action) {
                        const messageData = message[message.action.split(`/`).shift()];

                        messageData.subscriptionId = me._internalSubscriptionIdToExternal(message.subscriptionId);

                        if (messageData.timestamp) {
                            me.subscriptionLastTimestampMap.set(messageData.subscriptionId, messageData.timestamp);
                        }

                        me.emit(ApiStrategy.MESSAGE_EVENT, messageData);
                    } else {
                        me.emit(ApiStrategy.MESSAGE_EVENT, message);
                    }
                    break;
            }
        });

        me.transport.on(Transport.RECONNECTED_EVENT, () => {
            if (me.reAuthorizationHandler) {
                const subscriptionKeys = Array.from(me.subscriptionMap.keys());
                const subscriptionValues = Array.from(me.subscriptionMap.values());

                me.reAuthorizationHandler().then(() => Promise.all(subscriptionValues.map(({ key, parameters, body }) => me.send(key, parameters, body)))).then(() => subscriptionKeys.forEach(subscriptionId => me.subscriptionMap.delete(subscriptionId))).catch(error => me.emit(ApiStrategy.ERROR_EVENT, error));
            }
        });

        me.transport.on(Transport.ERROR_EVENT, error => me.emit(ApiStrategy.ERROR_EVENT, error));
    }

    get reconnectionAttempts() {
        const me = this;

        return me.transport.reconnectionAttempts;
    }

    set reconnectionAttempts(value) {
        const me = this;

        me.transport.reconnectionAttempts = value;
    }

    get reconnectionInterval() {
        const me = this;

        return me.transport.reconnectionInterval;
    }

    set reconnectionInterval(value) {
        const me = this;

        me.transport.reconnectionInterval = value;
    }

    /**
     * Connect transport
     * @returns {Promise<any>}
     */
    connect() {
        const me = this;

        return me.transport.connect();
    }

    /**
     * Authorize transport
     * @param accessToken
     * @returns {Promise}
     */
    authorize(accessToken) {
        const me = this;

        me.reAuthorizationHandler = () => me.transport.authenticate(accessToken);

        return me.transport.authenticate(accessToken);
    }

    /**
     * Send message via transport
     * @param key
     * @param parameters
     * @param body
     */
    send(key, parameters, body) {
        const me = this;
        const isSubscription = ApiMap.isSubscription(key);
        const isUnsubscription = ApiMap.isUnsubscription(key);
        let externalSubscriptionId, internalSubscriptionId;

        if (isSubscription) {
            me.subscriptionMap.forEach((subscriptionArguments, subscriptionId) => {
                if (subscriptionArguments.key === key && subscriptionArguments.parameters === parameters && subscriptionArguments.body === body) {
                    externalSubscriptionId = me._internalSubscriptionIdToExternal(subscriptionId);
                    internalSubscriptionId = subscriptionId;
                    parameters.timestamp = me.subscriptionLastTimestampMap.get(externalSubscriptionId);
                }
            });
        } else if (isUnsubscription) {
            externalSubscriptionId = parameters.subscriptionId;
            parameters.subscriptionId = me.subscriptionIdsMap.get(externalSubscriptionId);
        }

        const sendData = API.build(me.transport.type, key, parameters, body);

        switch (me.transport.type) {
            case HTTP.TYPE:
                sendData.endpoint = `${me.urlsMap.get(sendData.base)}${sendData.endpoint}`;
                break;
            case WS.TYPE:
                sendData.requestId = Utils.randomString();
                break;
        }

        function handleResponse(response) {
            let normalizedResponse = API.normalizeResponse(me.transport.type, key, response);

            if (isSubscription) {
                let newExternalSubscriptionId;

                if (internalSubscriptionId) {
                    me.subscriptionIdsMap.forEach((internalSubId, externalSubId) => {
                        if (internalSubscriptionId === internalSubId) {
                            newExternalSubscriptionId = externalSubId;
                        }
                    });
                } else {
                    newExternalSubscriptionId = Utils.randomString();
                }

                me.subscriptionMap.set(normalizedResponse.subscriptionId, { key, parameters, body });
                me.subscriptionIdsMap.set(newExternalSubscriptionId, normalizedResponse.subscriptionId);
                normalizedResponse = { subscriptionId: newExternalSubscriptionId };
            } else if (isUnsubscription) {
                me.subscriptionMap.delete(parameters.subscriptionId);
                me.subscriptionIdsMap.delete(externalSubscriptionId);
            }

            return normalizedResponse;
        }

        return me.transport.send(sendData).then(handleResponse).catch(error => {
            if (error === Utils.TOKEN_EXPIRED_MARK && me.reconnectionHandler) {
                return me.reconnectionHandler().then(() => me.transport.send(sendData)).then(handleResponse).catch(reconnectionError => {
                    throw reconnectionError;
                });
            } else {
                throw error;
            }
        });
    }

    /**
     * Disconnects transport
     */
    disconnect() {
        const me = this;

        me.transport.disconnect();
    }

    /**
     * Initialize all transport specific functionality
     * @private
     */
    _initTransportSpecificFunctionality() {
        const me = this;

        switch (me.transport.type) {
            case HTTP.TYPE:
                me.transport.initPingParameters(`${me.urlsMap.get(API.MAIN_BASE)}/info`, HTTP.GET_METHOD);
                break;
        }
    }

    /**
     *
     * @param subscriptionId
     * @returns {*}
     * @private
     */
    _externalSubscriptionIdToInternal(subscriptionId) {
        const me = this;

        return me.subscriptionIdsMap.get(subscriptionId) || subscriptionId;
    }

    /**
     *
     * @param subscriptionId
     * @returns {*}
     * @private
     */
    _internalSubscriptionIdToExternal(subscriptionId) {
        const me = this;
        let result = subscriptionId;

        me.subscriptionIdsMap.forEach((internalSubId, externalSubId) => {
            if (internalSubId === subscriptionId) {
                result = externalSubId;
            }
        });

        return result;
    }
}

module.exports = ApiStrategy;

},{"./controllers/API":22,"./controllers/transportResolvers/ApiMap":33,"./error/UnsupportedTransportError":41,"./transports/HTTP":76,"./transports/WS":77,"./transports/base/Transport":78,"./utils/Utils":79,"events":3}],21:[function(require,module,exports){
const Utils = require(`./utils/Utils`);
const EventEmitter = require('events');
const APIStrategy = require('./ApiStrategy');
const InfoAPI = require('./controllers/ServerInfoAPI');
const DeviceAPI = require('./controllers/DeviceAPI');
const DeviceTypeAPI = require('./controllers/DeviceTypeAPI');
const TokenAPI = require('./controllers/TokenAPI');
const NetworkAPI = require('./controllers/NetworkAPI');
const ConfigurationAPI = require('./controllers/ConfigurationAPI');
const CommandAPI = require('./controllers/DeviceCommandAPI');
const NotificationAPI = require('./controllers/DeviceNotificationAPI');
const UserAPI = require('./controllers/UserAPI');
const PluginAPI = require('./controllers/PluginAPI');
const Command = require(`./models/DeviceCommand`);
const Configuration = require(`./models/Configuration`);
const Device = require(`./models/Device`);
const DeviceType = require(`./models/DeviceType`);
const Network = require(`./models/Network`);
const Notification = require(`./models/DeviceNotification`);
const Plugin = require(`./models/Plugin`);
const UserToken = require(`./models/UserToken`);
const PluginToken = require(`./models/PluginToken`);
const User = require(`./models/User`);
const CommandGetQuery = require(`./models/query/CommandGetQuery`);
const CommandListQuery = require(`./models/query/CommandListQuery`);
const CommandPollManyQuery = require(`./models/query/CommandPollManyQuery`);
const CommandPollQuery = require(`./models/query/CommandPollQuery`);
const CommandWaitQuery = require(`./models/query/CommandWaitQuery`);
const DeviceCountQuery = require(`./models/query/DeviceCountQuery`);
const DeviceListQuery = require(`./models/query/DeviceListQuery`);
const DeviceTypeCountQuery = require(`./models/query/DeviceTypeCountQuery`);
const DeviceTypeListQuery = require(`./models/query/DeviceTypeListQuery`);
const DeviceTypeDeleteQuery = require('./models/query/DeviceTypeDeleteQuery');
const PluginUpdateQuery = require(`./models/query/PluginUpdateQuery`);
const NetworkCountQuery = require(`./models/query/NetworkCountQuery`);
const NetworkListQuery = require(`./models/query/NetworkListQuery`);
const NetworkDeleteQuery = require('./models/query/NetworkDeleteQuery');
const NotificationListQuery = require(`./models/query/NotificationListQuery`);
const NotificationPollManyQuery = require(`./models/query/NotificationPollManyQuery`);
const NotificationPollQuery = require(`./models/query/NotificationPollQuery`);
const UserCountQuery = require(`./models/query/UserCountQuery`);
const UserListQuery = require(`./models/query/UserListQuery`);
const PluginCountQuery = require(`./models/query/PluginCountQuery`);
const PluginListQuery = require(`./models/query/PluginListQuery`);
const PluginRegisterQuery = require(`./models/query/PluginRegisterQuery`);
const NoAuthCredentialsError = require('./error/NoAuthCredentialsError');
const InvalidCredentialsError = require('./error/InvalidCredentialsError');

/**
 * DeviceHive module
 */
class DeviceHive extends EventEmitter {

    static get MESSAGE_EVENT() {
        return APIStrategy.MESSAGE_EVENT;
    }
    static get ERROR_EVENT() {
        return APIStrategy.ERROR_EVENT;
    }

    /**
     * @type {Object} - Returns DeviceHive models
     */
    static get models() {
        return {
            Command: Command,
            Configuration: Configuration,
            Device: Device,
            DeviceType: DeviceType,
            Network: Network,
            Notification: Notification,
            Plugin: Plugin,
            PluginToken: PluginToken,
            User: User,
            UserToken: UserToken,
            query: {
                CommandGetQuery: CommandGetQuery,
                CommandListQuery: CommandListQuery,
                CommandPollManyQuery: CommandPollManyQuery,
                CommandPollQuery: CommandPollQuery,
                CommandWaitQuery: CommandWaitQuery,
                DeviceCountQuery: DeviceCountQuery,
                DeviceListQuery: DeviceListQuery,
                DeviceTypeCountQuery: DeviceTypeCountQuery,
                DeviceTypeListQuery: DeviceTypeListQuery,
                DeviceTypeDeleteQuery: DeviceTypeDeleteQuery,
                PluginUpdateQuery: PluginUpdateQuery,
                NetworkCountQuery: NetworkCountQuery,
                NetworkListQuery: NetworkListQuery,
                NetworkDeleteQuery: NetworkDeleteQuery,
                NotificationListQuery: NotificationListQuery,
                NotificationPollManyQuery: NotificationPollManyQuery,
                NotificationPollQuery: NotificationPollQuery,
                UserCountQuery: UserCountQuery,
                UserListQuery: UserListQuery,
                PluginCountQuery: PluginCountQuery,
                PluginListQuery: PluginListQuery,
                PluginRegisterQuery: PluginRegisterQuery
            }
        };
    }

    /**
     * DeviceHive module
     * @param {object} options - Initial settings
     * @param {string} [options.accessToken] - Access token
     * @param {string} [options.refreshToken] - Refresh token
     * @param {string} [options.login] - Login
     * @param {string} [options.password] - Password
     * @param {string} options.mainServiceURL - Main Service URL
     * @param {string} [options.authServiceURL] - Auth Service URL (required only for http)
     * @param {string} [options.pluginServiceURL] - Plugin Service URL (required only for http)
     */
    constructor({ mainServiceURL, authServiceURL, pluginServiceURL, accessToken, refreshToken, login, password, autoUpdateSession = true }) {
        super();

        const me = this;

        me.accessToken = accessToken;
        me.refreshToken = refreshToken;
        me.login = login;
        me.password = password;
        me.autoUpdateSession = autoUpdateSession;

        me.strategy = new APIStrategy({ mainServiceURL, authServiceURL, pluginServiceURL });

        me.info = new InfoAPI({ strategy: me.strategy });
        me.device = new DeviceAPI({ strategy: me.strategy });
        me.token = new TokenAPI({ strategy: me.strategy });
        me.network = new NetworkAPI({ strategy: me.strategy });
        me.deviceType = new DeviceTypeAPI({ strategy: me.strategy });
        me.configuration = new ConfigurationAPI({ strategy: me.strategy });
        me.command = new CommandAPI({ strategy: me.strategy });
        me.notification = new NotificationAPI({ strategy: me.strategy });
        me.user = new UserAPI({ strategy: me.strategy });
        me.plugin = new PluginAPI({ strategy: me.strategy });

        me.strategy.on(APIStrategy.MESSAGE_EVENT, message => me.emit(DeviceHive.MESSAGE_EVENT, message));
        me.strategy.on(APIStrategy.ERROR_EVENT, error => me.emit(DeviceHive.ERROR_EVENT, error && error.message ? error.message : error));

        me.on(DeviceHive.ERROR_EVENT, Utils.emptyFn);
    }

    /**
     * Connect to the DeviceHive service
     * @returns {Promise<DeviceHive>}
     */
    async connect({ accessToken, refreshToken, login, password, reconnectionAttempts, reconnectionInterval } = {}) {
        const me = this;

        me.strategy.reconnectionAttempts = reconnectionAttempts;
        me.strategy.reconnectionInterval = reconnectionInterval;

        if (!accessToken && !refreshToken && !(login && password)) {
            accessToken = accessToken || me.accessToken;
            refreshToken = refreshToken || me.refreshToken;
            login = login || me.login;
            password = password || me.password;
        }

        if (accessToken || refreshToken || login && password) {
            try {
                await me.strategy.connect();

                if (login && password) {
                    const { accessToken, refreshToken } = await me.token.login(login, password);

                    await me.strategy.authorize(accessToken);

                    me.accessToken = accessToken;
                    me.refreshToken = refreshToken;
                } else if (refreshToken) {
                    const { accessToken } = await me.token.refresh(refreshToken);

                    await me.strategy.authorize(accessToken);

                    me.accessToken = accessToken;
                    me.refreshToken = refreshToken;
                } else if (accessToken) {
                    await me.strategy.authorize(accessToken);

                    me.accessToken = accessToken;
                }

                if (me.autoUpdateSession === true) {
                    const userTokens = await me.token.createUserToken(Utils.createUserTokenFromJWT(me.accessToken));

                    me.accessToken = userTokens.accessToken;
                    me.refreshToken = userTokens.refreshToken;
                    me.strategy.reconnectionHandler = () => me.connect({ refreshToken: me.refreshToken });
                }
            } catch (error) {
                throw new InvalidCredentialsError(error);
            }
        } else {
            throw new NoAuthCredentialsError();
        }

        return me;
    }

    /**
     * Disconnects from DeviceHive server
     * @returns {*|void}
     */
    disconnect() {
        const me = this;

        return me.strategy.disconnect();
    }
}

module.exports = DeviceHive;

},{"./ApiStrategy":20,"./controllers/ConfigurationAPI":23,"./controllers/DeviceAPI":24,"./controllers/DeviceCommandAPI":25,"./controllers/DeviceNotificationAPI":26,"./controllers/DeviceTypeAPI":27,"./controllers/NetworkAPI":28,"./controllers/PluginAPI":29,"./controllers/ServerInfoAPI":30,"./controllers/TokenAPI":31,"./controllers/UserAPI":32,"./error/InvalidCredentialsError":36,"./error/NoAuthCredentialsError":38,"./models/Configuration":44,"./models/Device":45,"./models/DeviceCommand":46,"./models/DeviceNotification":47,"./models/DeviceType":48,"./models/Network":49,"./models/Plugin":50,"./models/PluginToken":51,"./models/User":52,"./models/UserToken":53,"./models/query/CommandGetQuery":54,"./models/query/CommandListQuery":55,"./models/query/CommandPollManyQuery":56,"./models/query/CommandPollQuery":57,"./models/query/CommandWaitQuery":58,"./models/query/DeviceCountQuery":59,"./models/query/DeviceListQuery":60,"./models/query/DeviceTypeCountQuery":61,"./models/query/DeviceTypeDeleteQuery":62,"./models/query/DeviceTypeListQuery":63,"./models/query/NetworkCountQuery":64,"./models/query/NetworkDeleteQuery":65,"./models/query/NetworkListQuery":66,"./models/query/NotificationListQuery":67,"./models/query/NotificationPollManyQuery":68,"./models/query/NotificationPollQuery":69,"./models/query/PluginCountQuery":70,"./models/query/PluginListQuery":71,"./models/query/PluginRegisterQuery":72,"./models/query/PluginUpdateQuery":73,"./models/query/UserCountQuery":74,"./models/query/UserListQuery":75,"./utils/Utils":79,"events":3}],22:[function(require,module,exports){
const ApiMap = require(`./transportResolvers/ApiMap`);

/**
 * API class
 */
class API {

    static get MAIN_BASE() {
        return ApiMap.MAIN_BASE;
    }
    static get AUTH_BASE() {
        return ApiMap.AUTH_BASE;
    }
    static get PLUGIN_BASE() {
        return ApiMap.PLUGIN_BASE;
    }

    /**
     * Builds data for selected transport
     * @param transport
     * @param key
     * @param parameters
     * @param body
     */
    static build(transport, key, parameters, body) {
        return ApiMap.build(transport, key, parameters, body);
    }

    /**
     *
     * @param transport
     * @param key
     * @param response
     * @returns {*}
     */
    static normalizeResponse(transport, key, response) {
        return ApiMap.normalizeResponse(transport, key, response);
    }

    /**
     * Creates new API class
     * @param strategy
     */
    constructor({ strategy }) {
        const me = this;

        me.strategy = strategy;
    }

    /**
     *
     * @param key
     * @param parameters
     * @param body
     * @returns {Promise}
     */
    send(key, parameters, body) {
        const me = this;

        return me.strategy.send(key, parameters, body);
    }
}

module.exports = API;

},{"./transportResolvers/ApiMap":33}],23:[function(require,module,exports){
const API = require('./API');
const ApiMap = require(`./transportResolvers/ApiMap`);

/**
 * Returns information about the current configuration
 */
class ConfigurationAPI extends API {

  /**
   * Creates ConfigurationAPI
   * @param {number} name
   * @returns {Promise} selected configuration
   */
  get(name) {
    return this.send(ApiMap.getConfiguration, { name: name });
  }

  /**
   * Updates a configuration
   * @param {Configuration} configuration
   * @returns {Promise} count of configuration
   */
  put(configuration) {
    return this.send(ApiMap.putConfiguration, configuration.toObject(), configuration.toObject());
  }

  /**
   * Deletes an existing configuration
   * @param {number} name
   * @returns {Promise}
   */
  delete(name) {
    return this.send(ApiMap.deleteConfiguration, { name: name });
  }
}

module.exports = ConfigurationAPI;

},{"./API":22,"./transportResolvers/ApiMap":33}],24:[function(require,module,exports){
const API = require('./API');
const ApiMap = require(`./transportResolvers/ApiMap`);
const DeviceCountQuery = require('../models/query/DeviceCountQuery');
const DeviceListQuery = require('../models/query/DeviceListQuery');

/**
 * Returns information about the current device
 */
class DeviceAPI extends API {

  /**
   * Creates DeviceAPI
   * @param {string} deviceId
   * @returns {Promise} selected device
   */
  get(deviceId) {
    return this.send(ApiMap.getDevice, { deviceId: deviceId });
  }

  /**
   * Return a list of devices
   * @param {DeviceListQuery} deviceListQuery
   * @returns {Promise} list of devices
   */
  list(deviceListQuery = new DeviceListQuery()) {
    return this.send(ApiMap.listDevice, deviceListQuery.toObject());
  }

  /**
   * Returns count of devices
   * @param {DeviceCountQuery} deviceCountQuery
   * @returns {Promise} count of devices
   */
  count(deviceCountQuery = new DeviceCountQuery()) {
    return this.send(ApiMap.countDevice, deviceCountQuery.toObject());
  }

  /**
   * Registers or updates a device
   * @param {object} device data
   * @returns {Promise} count of devices
   */
  add(device) {
    return this.send(ApiMap.addDevice, { deviceId: device.id }, device.toObject());
  }

  /**
   * Deletes an existing device
   * @param {string} deviceId
   * @returns {Promise}
   */
  delete(deviceId) {
    return this.send(ApiMap.deleteDevice, { deviceId: deviceId });
  }
}

module.exports = DeviceAPI;

},{"../models/query/DeviceCountQuery":59,"../models/query/DeviceListQuery":60,"./API":22,"./transportResolvers/ApiMap":33}],25:[function(require,module,exports){
const API = require('./API');
const ApiMap = require(`./transportResolvers/ApiMap`);
const CommandGetQuery = require('../models/query/CommandGetQuery');
const CommandListQuery = require('../models/query/CommandListQuery');
const CommandPollQuery = require('../models/query/CommandPollQuery');
const CommandPollManyQuery = require('../models/query/CommandPollManyQuery');
const CommandWaitQuery = require('../models/query/CommandWaitQuery');

/**
 * Returns information about the current command
 */
class DeviceCommandAPI extends API {

    /**
     * Creates DeviceCommandAPI
     * @param {number} deviceId - Device ID
     * @param {number} commandId - Command ID
     * @param {CommandGetQuery} commandGetQuery
     * @returns {Promise} selected command
     */
    get(deviceId, commandId, commandGetQuery = new CommandGetQuery()) {
        return this.send(ApiMap.getCommand, Object.assign({ deviceId: deviceId, commandId: commandId }, commandGetQuery.toObject()));
    }

    /**
     * Return a list of commands
     * @param {CommandListQuery} commandListQuery
     * @returns {Promise} list of commands
     */
    list(commandListQuery = new CommandListQuery()) {
        return this.send(ApiMap.listCommand, commandListQuery.toObject());
    }

    /**
     * Registers a command
     * @param {number} deviceId - Device ID
     * @param {Command} command
     * @returns {Promise} count of commands
     */
    insert(deviceId, command) {
        return this.send(ApiMap.insertCommand, { deviceId: deviceId }, command.toObject());
    }

    /**
     * Updates a command
     * @param {Command} command
     * @returns {Promise} count of commands
     */
    update(command) {
        return this.send(ApiMap.updateCommand, { deviceId: command.deviceId, commandId: command.id }, command.toObject());
    }

    /**
     * Poll commands
     * @param {CommandPollQuery} commandPollQuery
     * @returns {Promise}
     */
    poll(commandPollQuery = new CommandPollQuery()) {
        return this.send(ApiMap.pollCommand, commandPollQuery.toObject());
    }

    /**
     * Poll many commands
     * @param {CommandPollManyQuery} commandPollManyQuery
     * @returns {Promise}
     */
    pollMany(commandPollManyQuery = new CommandPollManyQuery()) {
        return this.send(ApiMap.pollManyCommand, commandPollManyQuery.toObject());
    }

    /**
     * Wait for command to be processed
     * @param deviceId
     * @param commandId
     * @param {CommandWaitQuery} commandWaitQuery
     * @returns {Promise}
     */
    wait(deviceId, commandId, commandWaitQuery = new CommandWaitQuery()) {
        return this.send(ApiMap.waitCommand, Object.assign({}, {
            deviceId,
            commandId
        }, commandWaitQuery.toObject()));
    }

    /**
     * Subscribe for command creation events
     * @param {CommandPollQuery} commandPollQuery
     * @returns {Promise}
     */
    subscribe(commandPollQuery = new CommandPollQuery()) {
        return this.send(ApiMap.subscribeCommand, commandPollQuery.toObject());
    }

    /**
     * Unsubscribe for command creation events
     * @param {Number} subscriptionId
     * @returns {Promise}
     */
    unsubscribe(subscriptionId) {
        return this.send(ApiMap.unsubscribeCommand, { subscriptionId: subscriptionId });
    }
}

module.exports = DeviceCommandAPI;

},{"../models/query/CommandGetQuery":54,"../models/query/CommandListQuery":55,"../models/query/CommandPollManyQuery":56,"../models/query/CommandPollQuery":57,"../models/query/CommandWaitQuery":58,"./API":22,"./transportResolvers/ApiMap":33}],26:[function(require,module,exports){
const API = require('./API');
const ApiMap = require(`./transportResolvers/ApiMap`);
const NotificationListQuery = require('../models/query/NotificationListQuery');
const NotificationPollQuery = require('../models/query/NotificationPollQuery');
const NotificationPollManyQuery = require('../models/query/NotificationPollManyQuery');

/**
 * Returns information about the current notification
 */
class DeviceNotificationAPI extends API {

  /**
   * Creates DeviceNotificationAPI
   * @param {number} deviceId - Device ID
   * @param {number} notificationId - Notification ID
   * @returns {Promise} selected notification
   */
  get(deviceId, notificationId) {
    return this.send(ApiMap.getNotification, { deviceId: deviceId, notificationId: notificationId });
  }

  /**
   * Return a list of notifications
   * @param {NotificationListQuery} notificationListQuery
   * @returns {Promise} list of notifications
   */
  list(notificationListQuery = new NotificationListQuery()) {
    return this.send(ApiMap.listNotification, notificationListQuery.toObject());
  }

  /**
   * Registers a notification
   * @param {Number} deviceId
   * @param {Notification} notification
   * @returns {Promise} count of notifications
   */
  insert(deviceId, notification) {
    return this.send(ApiMap.insertNotification, { deviceId }, notification.toObject());
  }

  /**
   * Poll notifications
   * @param {NotificationPollQuery} notificationPollQuery
   * @returns {*}
   */
  poll(notificationPollQuery = new NotificationPollQuery()) {
    return this.send(ApiMap.pollNotification, notificationPollQuery.toObject());
  }

  /**
   * Poll many notifications
   * @param {NotificationPollManyQuery} notificationPollManyQuery
   * @returns {*}
   */
  pollMany(notificationPollManyQuery = new NotificationPollManyQuery()) {
    return this.send(ApiMap.pollManyNotification, notificationPollManyQuery.toObject());
  }

  /**
   * Subscribe for new notifications
   * @param {NotificationPollQuery} notificationPollQuery
   * @returns {Promise}
   */
  subscribe(notificationPollQuery = new NotificationPollQuery()) {
    return this.send(ApiMap.subscribeNotification, notificationPollQuery.toObject());
  }

  /**
   * Unsubscribe from notifications creation
   * @param {Number} subscriptionId
   * @returns {Promise}
   */
  unsubscribe(subscriptionId) {
    return this.send(ApiMap.unsubscribeNotification, { subscriptionId: subscriptionId });
  }
}

module.exports = DeviceNotificationAPI;

},{"../models/query/NotificationListQuery":67,"../models/query/NotificationPollManyQuery":68,"../models/query/NotificationPollQuery":69,"./API":22,"./transportResolvers/ApiMap":33}],27:[function(require,module,exports){
const API = require('./API');
const ApiMap = require(`./transportResolvers/ApiMap`);
const DeviceTypeListQuery = require('../models/query/DeviceTypeListQuery');
const DeviceTypeCountQuery = require('../models/query/DeviceTypeCountQuery');
const DeviceTypeDeleteQuery = require('../models/query/DeviceTypeDeleteQuery');

/**
 * Returns information about the current deviceType
 */
class DeviceTypeAPI extends API {

  /**
   * Creates DeviceTypeAPI
   * @param {number} deviceTypeId - Device type ID
   * @returns {Promise} selected deviceType
   */
  get(deviceTypeId) {
    return this.send(ApiMap.getDeviceType, { deviceTypeId: deviceTypeId });
  }

  /**
   * Return a list of deviceTypes
   * @param {DeviceTypeListQuery} deviceTypeListQuery
   * @returns {Promise} list of deviceTypes
   */
  list(deviceTypeListQuery = new DeviceTypeListQuery()) {
    return this.send(ApiMap.listDeviceType, deviceTypeListQuery.toObject());
  }

  /**
   * Returns count of deviceTypes
   * @param {DeviceTypeCountQuery} deviceTypeCountQuery
   * @returns {Promise} count of deviceTypes
   */
  count(deviceTypeCountQuery = new DeviceTypeCountQuery()) {
    return this.send(ApiMap.countDeviceType, deviceTypeCountQuery.toObject());
  }

  /**
   * Registers a deviceType
   * @param {DeviceType} deviceType data
   * @returns {Promise} count of deviceTypes
   */
  insert(deviceType) {
    return this.send(ApiMap.addDeviceType, {}, deviceType.toObject());
  }

  /**
   * Updates a deviceType
   * @param {DeviceType} deviceType data
   * @returns {Promise} count of deviceTypes
   */
  update(deviceType) {
    return this.send(ApiMap.updateDeviceType, { deviceTypeId: deviceType.id }, deviceType.toObject());
  }

  /**
   * Deletes an existing deviceType
   * @param {DeviceTypeDeleteQuery} deviceTypeDeleteQuery
   * @returns {Promise}
   */
  delete(deviceTypeDeleteQuery = new DeviceTypeDeleteQuery()) {
    return this.send(ApiMap.deleteDeviceType, deviceTypeDeleteQuery.toObject());
  }
}

module.exports = DeviceTypeAPI;

},{"../models/query/DeviceTypeCountQuery":61,"../models/query/DeviceTypeDeleteQuery":62,"../models/query/DeviceTypeListQuery":63,"./API":22,"./transportResolvers/ApiMap":33}],28:[function(require,module,exports){
const API = require('./API');
const ApiMap = require(`./transportResolvers/ApiMap`);
const NetworkListQuery = require('../models/query/NetworkListQuery');
const NetworkCountQuery = require('../models/query/NetworkCountQuery');
const NetworkDeleteQuery = require('../models/query/NetworkDeleteQuery');

/**
 * Returns information about the current network
 */
class NetworkAPI extends API {

  /**
   * Returns a network
   * @param {number} networkId Network id
   * @returns {Promise} selected network
   */
  get(networkId) {
    return this.send(ApiMap.getNetwork, { networkId: networkId });
  }

  /**
   * Return a list of networks
   * @param {NetworkListQuery} networkListQuery
   * @returns {Promise} list of networks
   */
  list(networkListQuery = new NetworkListQuery()) {
    return this.send(ApiMap.listNetwork, networkListQuery.toObject());
  }

  /**
   * Returns count of networks
   * @param {NetworkCountQuery} networkCountQuery
   * @returns {Promise} count of networks
   */
  count(networkCountQuery = new NetworkCountQuery()) {
    return this.send(ApiMap.countNetwork, networkCountQuery.toObject());
  }

  /**
   * Registers a network
   * @param {Network} network data
   * @returns {Promise} Network
   */
  insert(network) {
    return this.send(ApiMap.addNetwork, {}, network.toObject());
  }

  /**
   * Updates a network
   * @param {Network} network data
   * @returns {Promise} Network
   */
  update(network) {
    return this.send(ApiMap.updateNetwork, { networkId: network.id }, network.toObject());
  }

  /**
   * Deletes an existing network
   * @param {NetworkDeleteQuery} networkDeleteQuery
   * @returns {Promise} Network
   */
  delete(networkDeleteQuery = new NetworkDeleteQuery()) {
    return this.send(ApiMap.deleteNetwork, networkDeleteQuery.toObject());
  }
}

module.exports = NetworkAPI;

},{"../models/query/NetworkCountQuery":64,"../models/query/NetworkDeleteQuery":65,"../models/query/NetworkListQuery":66,"./API":22,"./transportResolvers/ApiMap":33}],29:[function(require,module,exports){
const API = require('./API');
const ApiMap = require(`./transportResolvers/ApiMap`);
const PluginCountQuery = require('../models/query/PluginCountQuery');
const PluginListQuery = require('../models/query/PluginListQuery');
const PluginRegisterQuery = require('../models/query/PluginRegisterQuery');
const PluginUpdateQuery = require('../models/query/PluginUpdateQuery');

/**
 * Returns information about the current plugin
 */
class PluginAPI extends API {

    /**
     * Return a list of plugins
     * @param {PluginListQuery} pluginListQuery
     * @returns {Promise} list of plugins
     */
    list(pluginListQuery = new PluginListQuery()) {
        return this.send(ApiMap.listPlugin, pluginListQuery.toObject());
    }

    /**
     * Returns count of plugins
     * @param {PluginCountQuery} pluginCountQuery
     * @returns {Promise} count of plugins
     */
    count(pluginCountQuery = new PluginCountQuery()) {
        return this.send(ApiMap.countPlugin, pluginCountQuery.toObject());
    }

    /**
     * Registers a plugin
     * @param {Plugin} plugin
     * @param {PluginRegisterQuery} pluginRegisterQuery
     * @returns {Promise} Plugin
     */
    register(plugin, pluginRegisterQuery = new PluginRegisterQuery()) {
        return this.send(ApiMap.registerPlugin, pluginRegisterQuery.toObject(), {
            name: plugin.name,
            description: plugin.description,
            parameters: plugin.parameters
        });
    }

    /**
     * Updates a plugin
     * @param {PluginUpdateQuery} pluginUpdateQuery
     * @returns {Promise} Plugin
     */
    update(pluginUpdateQuery = new PluginUpdateQuery()) {
        return this.send(ApiMap.updatePlugin, pluginUpdateQuery.toObject());
    }

    /**
     * Deletes an existing plugin
     * @param {string} topicName
     * @returns {Promise} Plugin
     */
    delete(topicName) {
        return this.send(ApiMap.deletePlugin, { topicName });
    }
}

module.exports = PluginAPI;

},{"../models/query/PluginCountQuery":70,"../models/query/PluginListQuery":71,"../models/query/PluginRegisterQuery":72,"../models/query/PluginUpdateQuery":73,"./API":22,"./transportResolvers/ApiMap":33}],30:[function(require,module,exports){
const API = require('./API');
const ApiMap = require(`./transportResolvers/ApiMap`);

/**
 * Get server info
 */
class InfoAPI extends API {

  /**
   * Get server info
   * @returns {Promise}
   */
  getServerInfo() {
    return this.send(ApiMap.getServerInfo);
  }

  /**
   * Get cache info
   * @returns {Promise}
   */
  getCacheInfo() {
    return this.send(ApiMap.getCacheInfo);
  }

  /**
   * Get cluster info
   * @returns {Promise}
   */
  getClusterInfo() {
    return this.send(ApiMap.getClusterInfo);
  }
}

module.exports = InfoAPI;

},{"./API":22,"./transportResolvers/ApiMap":33}],31:[function(require,module,exports){
const API = require('./API');
const ApiMap = require(`./transportResolvers/ApiMap`);

/**
 * Authenticate using login and password
 */
class TokenAPI extends API {

  /**
   * Creates TokenAPI
   * @param {string} login
   * @param {string} password
   */
  login(login, password) {
    return this.send(ApiMap.login, {}, { login, password });
  }

  /**
   * Create user token
   * @param {string} token Plugin token
   */
  authPlugin(token) {
    return this.send(ApiMap.authenticatePlugin, { token });
  }

  /**
   * Create user token
   * @param {UserToken} userToken
   */
  createUserToken(userToken) {
    return this.send(ApiMap.createUserToken, {}, userToken.toObject());
  }

  /**
   * Create plugin token
   * @param {PluginToken} pluginToken
   */
  createPluginToken(pluginToken) {
    return this.send(ApiMap.createPluginToken, {}, pluginToken.toObject());
  }

  /**
   * Refresh token
   * @param {string} refreshToken
   */
  refresh(refreshToken) {
    return this.send(ApiMap.refreshToken, {}, { refreshToken: refreshToken });
  }
}

module.exports = TokenAPI;

},{"./API":22,"./transportResolvers/ApiMap":33}],32:[function(require,module,exports){
const API = require('./API');
const ApiMap = require(`./transportResolvers/ApiMap`);
const UserListQuery = require('../models/query/UserListQuery');
const UserCountQuery = require('../models/query/UserCountQuery');

/**
 * Return a list of users
 */
class UserAPI extends API {

  /**
   * Creates UserAPI
   * @param {UserListQuery} userListQuery
   * @returns {Promise} list of users
   */
  list(userListQuery = new UserListQuery()) {
    return this.send(ApiMap.listUser, userListQuery.toObject());
  }

  /**
   * Returns count of users
   * @param {UserCountQuery} userCountQuery
   * @returns {Promise} count of users
   */
  count(userCountQuery = new UserCountQuery()) {
    return this.send(ApiMap.countUser, userCountQuery.toObject());
  }

  /**
   * Returns information about the current user
   * @param {number} userId
   * @returns {Promise} selected user
   */
  get(userId) {
    return this.send(ApiMap.getUser, { userId: userId });
  }

  /**
   * Registers a user
   * @param {User} user data
   * @returns {Promise} count of users
   */
  insert(user) {
    return this.send(ApiMap.addUser, {}, user.toObject());
  }

  /**
   * Updates a user (only for administrators)
   * @param {User} user data
   * @returns {Promise} count of users
   */
  update(user) {
    return this.send(ApiMap.updateUser, { userId: user.id }, user.toObject());
  }

  /**
   * Deletes an existing user
   * @param {number} userId
   * @returns {Promise}
   */
  delete(userId) {
    return this.send(ApiMap.deleteUser, { userId: userId });
  }

  /**
   * Returns information about the current user
   * @returns {Promise} selected user
   */
  getCurrent() {
    return this.send(ApiMap.getCurrentUser);
  }

  /**
   * Updates a user (only for administrators)
   * @param {User} user data
   * @returns {Promise} count of users
   */
  updateCurrent(user) {
    return this.send(ApiMap.updateCurrentUser, {}, user.toObject());
  }

  /**
   * Returns user's device types
   * @param userId
   * @returns {Promise}
   */
  getDeviceTypes(userId) {
    return this.send(ApiMap.getUserDeviceTypes, { userId: userId });
  }

  /**
   * Unassigns all user's device types
   * @param userId
   * @returns {Promise}
   */
  unassignAllDeviceTypes(userId) {
    return this.send(ApiMap.unassignAllDeviceTypes, { userId: userId });
  }

  /**
   * Assigns all device types to user
   * @param userId
   * @returns {Promise}
   */
  assignAllDeviceTypes(userId) {
    return this.send(ApiMap.assignAllDeviceTypes, { userId: userId });
  }

  /**
   * Unassigns mentioned device type
   * @param userId
   * @param deviceTypeId
   * @returns {Promise}
   */
  unassignDeviceType(userId, deviceTypeId) {
    return this.send(ApiMap.unassignDeviceType, { userId: userId, deviceTypeId: deviceTypeId });
  }

  /**
   * Returns user's device type by id
   * @param userId
   * @param deviceTypeId
   * @returns {Promise}
   */
  getDeviceType(userId, deviceTypeId) {
    return this.send(ApiMap.getUserDeviceType, { userId: userId, deviceTypeId: deviceTypeId });
  }

  /**
   * Assigns mentioned device type to user
   * @param userId
   * @param deviceTypeId
   * @returns {Promise}
   */
  assignDeviceType(userId, deviceTypeId) {
    return this.send(ApiMap.assignDeviceType, { userId: userId, deviceTypeId: deviceTypeId });
  }

  /**
   * Gets information about user/network association
   * @param {number} userId - User ID
   * @param {number} networkId - Network ID
   * @returns {Promise}
   */
  getNetwork(userId, networkId) {
    return this.send(ApiMap.getUserNetwork, { userId: userId, networkId: networkId });
  }

  /**
   * Associates network with the user
   * @param {number} userId - User ID
   * @param {number} networkId - Network ID
   * @returns {Promise}
   */
  assignNetwork(userId, networkId) {
    return this.send(ApiMap.assignNetwork, { userId: userId, networkId: networkId });
  }

  /**
   * Removes association between network and user
   * @param {number} userId - User ID
   * @param {number} networkId - Network ID
   * @returns {Promise}
   */
  unassignNetwork(userId, networkId) {
    return this.send(ApiMap.unassignNetwork, { userId: userId, networkId: networkId });
  }

}

module.exports = UserAPI;

},{"../models/query/UserCountQuery":74,"../models/query/UserListQuery":75,"./API":22,"./transportResolvers/ApiMap":33}],33:[function(require,module,exports){
const HttpApiResolver = require(`./HttpApiResolver`);
const WebSocketApiResolver = require(`./WebSocketApiResolver`);

const NoApiError = require('../../error/NoApiError');
const UnsupportedApiTransportError = require('../../error/UnsupportedApiTransportError');

const apiMap = new Map();

/**
 * Api Map
 */
class ApiMap {

    static get login() {
        return 'login';
    }
    static get createUserToken() {
        return 'createUserToken';
    }
    static get createPluginToken() {
        return 'createPluginToken';
    }
    static get refreshToken() {
        return 'refreshToken';
    }
    static get authenticatePlugin() {
        return 'authenticatePlugin';
    }

    static get getServerInfo() {
        return 'getServerInfo';
    }
    static get getCacheInfo() {
        return 'getCacheInfo';
    }
    static get getClusterInfo() {
        return 'getClusterInfo';
    }

    static get getConfiguration() {
        return 'getConfiguration';
    }
    static get putConfiguration() {
        return 'putConfiguration';
    }
    static get deleteConfiguration() {
        return 'deleteConfiguration';
    }

    static get listDevice() {
        return 'listDevice';
    }
    static get countDevice() {
        return 'countDevice';
    }
    static get getDevice() {
        return 'getDevice';
    }
    static get addDevice() {
        return 'addDevice';
    }
    static get deleteDevice() {
        return 'deleteDevice';
    }

    static get listDeviceType() {
        return 'listDeviceType';
    }
    static get countDeviceType() {
        return 'countDeviceType';
    }
    static get getDeviceType() {
        return 'getDeviceType';
    }
    static get addDeviceType() {
        return 'addDeviceType';
    }
    static get updateDeviceType() {
        return 'updateDeviceType';
    }
    static get deleteDeviceType() {
        return 'deleteDeviceType';
    }

    static get getCommand() {
        return 'getCommand';
    }
    static get listCommand() {
        return 'listCommand';
    }
    static get insertCommand() {
        return 'insertCommand';
    }
    static get subscribeCommand() {
        return 'subscribeCommand';
    }
    static get pollCommand() {
        return 'pollCommand';
    }
    static get pollManyCommand() {
        return 'pollManyCommand';
    }
    static get waitCommand() {
        return 'waitCommand';
    }
    static get unsubscribeCommand() {
        return 'unsubscribeCommand';
    }
    static get updateCommand() {
        return 'updateCommand';
    }

    static get getNotification() {
        return 'getNotification';
    }
    static get listNotification() {
        return 'listNotification';
    }
    static get insertNotification() {
        return 'insertNotification';
    }
    static get subscribeNotification() {
        return 'subscribeNotification';
    }
    static get unsubscribeNotification() {
        return 'unsubscribeNotification';
    }
    static get pollNotification() {
        return 'pollNotification';
    }
    static get pollManyNotification() {
        return 'pollManyNotification';
    }

    static get listNetwork() {
        return 'listNetwork';
    }
    static get countNetwork() {
        return 'countNetwork';
    }
    static get getNetwork() {
        return 'getNetwork';
    }
    static get addNetwork() {
        return 'addNetwork';
    }
    static get updateNetwork() {
        return 'updateNetwork';
    }
    static get deleteNetwork() {
        return 'deleteNetwork';
    }

    static get listUser() {
        return 'listUser';
    }
    static get countUser() {
        return 'countUser';
    }
    static get getUser() {
        return 'getUser';
    }
    static get addUser() {
        return 'addUser';
    }
    static get updateUser() {
        return 'updateUser';
    }
    static get deleteUser() {
        return 'deleteUser';
    }
    static get getCurrentUser() {
        return 'getCurrentUser';
    }
    static get updateCurrentUser() {
        return 'updateCurrentUser';
    }
    static get getUserDeviceTypes() {
        return 'getUserDeviceTypes';
    }
    static get assignAllDeviceTypes() {
        return 'assignAllDeviceTypes';
    }
    static get unassignAllDeviceTypes() {
        return 'unassignAllDeviceTypes';
    }
    static get getUserDeviceType() {
        return 'getUserDeviceType';
    }
    static get assignDeviceType() {
        return 'assignDeviceType';
    }
    static get unassignDeviceType() {
        return 'unassignDeviceType';
    }
    static get getUserNetwork() {
        return 'getUserNetwork';
    }
    static get assignNetwork() {
        return 'assignNetwork';
    }
    static get unassignNetwork() {
        return 'unassignNetwork';
    }

    static get listPlugin() {
        return 'listPlugin';
    }
    static get countPlugin() {
        return 'countPlugin';
    }
    static get registerPlugin() {
        return 'registerPlugin';
    }
    static get deletePlugin() {
        return 'deletePlugin';
    }
    static get updatePlugin() {
        return 'updatePlugin';
    }

    static get HTTP_API() {
        return `http`;
    }
    static get WS_API() {
        return `ws`;
    }

    static get MAIN_BASE() {
        return `main`;
    }
    static get AUTH_BASE() {
        return `auth`;
    }
    static get PLUGIN_BASE() {
        return `plugin`;
    }

    /**
     *
     * @param key
     */
    static isSubscription(key) {
        return key === ApiMap.subscribeNotification || key === ApiMap.subscribeCommand;
    }

    /**
     *
     * @param key
     */
    static isUnsubscription(key) {
        return key === ApiMap.unsubscribeNotification || key === ApiMap.unsubscribeCommand;
    }

    /**
     *
     * @param transport
     * @param key
     * @param parameters
     * @param body
     * @returns {Object}
     */
    static build(transport, key, parameters, body) {
        let transportAPI;

        const apiObject = apiMap.get(key);

        if (!apiObject) {
            throw new NoApiError();
        }

        const transportApiObject = apiObject[transport];

        if (!transportApiObject) {
            throw new UnsupportedApiTransportError({ key, transport });
        }

        switch (transport) {
            case ApiMap.HTTP_API:
                transportAPI = new HttpApiResolver(transportApiObject);
                break;
            case ApiMap.WS_API:
                transportAPI = new WebSocketApiResolver(transportApiObject);
                break;
        }

        return transportAPI.build(parameters, body);
    }

    /**
     *
     * @param transport
     * @param key
     * @param response
     * @returns {*}
     */
    static normalizeResponse(transport, key, response) {
        let normalizedResponse = {};

        switch (transport) {
            case ApiMap.HTTP_API:
                normalizedResponse = HttpApiResolver.normalizeResponse(response);
                break;
            case ApiMap.WS_API:
                normalizedResponse = WebSocketApiResolver.normalizeResponse(response, apiMap.get(key)[transport].response);
                break;
        }

        return normalizedResponse;
    }
}

apiMap.set(ApiMap.login, { http: { method: 'POST', uri: '/token', base: ApiMap.AUTH_BASE, noAuth: true }, ws: { action: 'token', response: [`accessToken`, `refreshToken`] } });
apiMap.set(ApiMap.createUserToken, { http: { method: 'POST', uri: '/token/create', base: ApiMap.AUTH_BASE }, ws: { action: 'token/create', bodyKey: 'payload', response: [`accessToken`, `refreshToken`] } });
apiMap.set(ApiMap.createPluginToken, { http: { method: 'POST', uri: '/token/plugin/create', base: ApiMap.AUTH_BASE } });
apiMap.set(ApiMap.refreshToken, { http: { method: 'POST', uri: '/token/refresh', base: ApiMap.AUTH_BASE, noAuth: true }, ws: { action: 'token/refresh', response: [`accessToken`] } });
apiMap.set(ApiMap.authenticatePlugin, { http: { method: 'GET', uri: '/token/plugin/authenticate', base: ApiMap.AUTH_BASE } });

apiMap.set(ApiMap.getServerInfo, { http: { method: 'GET', uri: '/info', base: ApiMap.MAIN_BASE, noAuth: true }, ws: { action: 'server/info', response: { bodyKey: `info` } } });
apiMap.set(ApiMap.getCacheInfo, { http: { method: 'GET', uri: '/info/cache', base: ApiMap.MAIN_BASE, noAuth: true } });
apiMap.set(ApiMap.getClusterInfo, { http: { method: 'GET', uri: '/info/config/cluster', base: ApiMap.MAIN_BASE, noAuth: true }, ws: { action: 'cluster/info', response: { bodyKey: `clusterInfo` } } });

apiMap.set(ApiMap.getConfiguration, { http: { method: 'GET', uri: '/configuration/{name}', base: ApiMap.MAIN_BASE }, ws: { action: 'configuration/get', response: { bodyKey: `configuration` } } });
apiMap.set(ApiMap.putConfiguration, { http: { method: 'PUT', uri: '/configuration/{name}', base: ApiMap.MAIN_BASE }, ws: { action: 'configuration/put', response: { bodyKey: `configuration` } } });
apiMap.set(ApiMap.deleteConfiguration, { http: { method: 'DELETE', uri: '/configuration/{name}', base: ApiMap.MAIN_BASE }, ws: { action: 'configuration/delete', response: null } });

apiMap.set(ApiMap.listDevice, { http: { method: 'GET', uri: '/device', base: ApiMap.MAIN_BASE }, ws: { action: 'device/list', response: { bodyKey: `devices` } } });
apiMap.set(ApiMap.countDevice, { http: { method: 'GET', uri: '/device/count', base: ApiMap.MAIN_BASE }, ws: { action: 'device/count', response: [`count`] } });
apiMap.set(ApiMap.getDevice, { http: { method: 'GET', uri: '/device/{deviceId}', base: ApiMap.MAIN_BASE }, ws: { action: 'device/get', response: { bodyKey: `device` } } });
apiMap.set(ApiMap.addDevice, { http: { method: 'PUT', uri: '/device/{deviceId}', base: ApiMap.MAIN_BASE }, ws: { action: 'device/save', bodyKey: 'device', response: null } });
apiMap.set(ApiMap.deleteDevice, { http: { method: 'DELETE', uri: '/device/{deviceId}', base: ApiMap.MAIN_BASE }, ws: { action: 'device/delete', response: null } });

apiMap.set(ApiMap.listDeviceType, { http: { method: 'GET', uri: '/devicetype', base: ApiMap.MAIN_BASE }, ws: { action: 'devicetype/list', response: { bodyKey: 'deviceTypes' } } });
apiMap.set(ApiMap.countDeviceType, { http: { method: 'GET', uri: '/devicetype/count', base: ApiMap.MAIN_BASE }, ws: { action: 'devicetype/count', response: [`count`] } });
apiMap.set(ApiMap.getDeviceType, { http: { method: 'GET', uri: '/devicetype/{deviceTypeId}', base: ApiMap.MAIN_BASE }, ws: { action: 'devicetype/get', response: { bodyKey: 'deviceType' } } });
apiMap.set(ApiMap.addDeviceType, { http: { method: 'POST', uri: '/devicetype', base: ApiMap.MAIN_BASE }, ws: { action: 'devicetype/insert', bodyKey: 'deviceType', response: { bodyKey: 'deviceType' } } });
apiMap.set(ApiMap.updateDeviceType, { http: { method: 'PUT', uri: '/devicetype/{deviceTypeId}', base: ApiMap.MAIN_BASE }, ws: { action: 'devicetype/update', bodyKey: 'deviceType', response: null } });
apiMap.set(ApiMap.deleteDeviceType, { http: { method: 'DELETE', uri: '/devicetype/{deviceTypeId}', base: ApiMap.MAIN_BASE }, ws: { action: 'devicetype/delete', response: null } });

apiMap.set(ApiMap.listCommand, { http: { method: 'GET', uri: '/device/{deviceId}/command', base: ApiMap.MAIN_BASE }, ws: { action: 'command/list', response: { bodyKey: 'commands' } } });
apiMap.set(ApiMap.getCommand, { http: { method: 'GET', uri: '/device/{deviceId}/command/{commandId}', base: ApiMap.MAIN_BASE }, ws: { action: 'command/get', response: { bodyKey: 'command' } } });
apiMap.set(ApiMap.insertCommand, { http: { method: 'POST', uri: '/device/{deviceId}/command', base: ApiMap.MAIN_BASE }, ws: { action: 'command/insert', bodyKey: 'command', response: { bodyKey: 'command' } } });
apiMap.set(ApiMap.updateCommand, { http: { method: 'PUT', uri: '/device/{deviceId}/command/{commandId}', base: ApiMap.MAIN_BASE }, ws: { action: 'command/update', bodyKey: 'command', response: null } });
apiMap.set(ApiMap.pollCommand, { http: { method: 'GET', uri: '/device/{deviceId}/command/poll', base: ApiMap.MAIN_BASE } });
apiMap.set(ApiMap.pollManyCommand, { http: { method: 'GET', uri: '/device/command/poll', base: ApiMap.MAIN_BASE } });
apiMap.set(ApiMap.waitCommand, { http: { method: 'GET', uri: '/device/{deviceId}/command/{commandId}/poll', base: ApiMap.MAIN_BASE } });
apiMap.set(ApiMap.subscribeCommand, { http: { method: 'GET', uri: '/device/command/poll', base: ApiMap.MAIN_BASE, subscription: true }, ws: { action: 'command/subscribe', response: [`subscriptionId`] } });
apiMap.set(ApiMap.unsubscribeCommand, { http: { unsubscription: true }, ws: { action: 'command/unsubscribe', response: null } });

apiMap.set(ApiMap.listNotification, { http: { method: 'GET', uri: '/device/{deviceId}/notification', base: ApiMap.MAIN_BASE }, ws: { action: 'notification/list', response: { bodyKey: 'notifications' } } });
apiMap.set(ApiMap.getNotification, { http: { method: 'GET', uri: '/device/{deviceId}/notification/{notificationId}', base: ApiMap.MAIN_BASE }, ws: { action: 'notification/get', response: { bodyKey: 'notification' } } });
apiMap.set(ApiMap.insertNotification, { http: { method: 'POST', uri: '/device/{deviceId}/notification', base: ApiMap.MAIN_BASE }, ws: { action: 'notification/insert', bodyKey: 'notification', response: { bodyKey: 'notification' } } });
apiMap.set(ApiMap.pollNotification, { http: { method: 'GET', uri: '/device/{deviceId}/notification/poll', base: ApiMap.MAIN_BASE } });
apiMap.set(ApiMap.pollManyNotification, { http: { method: 'GET', uri: '/device/notification/poll', base: ApiMap.MAIN_BASE } });
apiMap.set(ApiMap.subscribeNotification, { http: { method: 'GET', uri: '/device/notification/poll', base: ApiMap.MAIN_BASE, subscription: true }, ws: { action: 'notification/subscribe', response: [`subscriptionId`] } });
apiMap.set(ApiMap.unsubscribeNotification, { http: { unsubscription: true }, ws: { action: 'notification/unsubscribe', response: null } });

apiMap.set(ApiMap.listNetwork, { http: { method: 'GET', uri: '/network', base: ApiMap.MAIN_BASE }, ws: { action: 'network/list', response: { bodyKey: 'networks' } } });
apiMap.set(ApiMap.countNetwork, { http: { method: 'GET', uri: '/network/count', base: ApiMap.MAIN_BASE }, ws: { action: 'network/count', response: [`count`] } });
apiMap.set(ApiMap.getNetwork, { http: { method: 'GET', uri: '/network/{networkId}', base: ApiMap.MAIN_BASE }, ws: { action: 'network/get', response: { bodyKey: 'network' } } });
apiMap.set(ApiMap.addNetwork, { http: { method: 'POST', uri: '/network', base: ApiMap.MAIN_BASE }, ws: { action: 'network/insert', bodyKey: 'network', response: { bodyKey: 'network' } } });
apiMap.set(ApiMap.updateNetwork, { http: { method: 'PUT', uri: '/network/{networkId}', base: ApiMap.MAIN_BASE }, ws: { action: 'network/update', bodyKey: 'network', response: null } });
apiMap.set(ApiMap.deleteNetwork, { http: { method: 'DELETE', uri: '/network/{networkId}', base: ApiMap.MAIN_BASE }, ws: { action: 'network/delete', response: null } });

apiMap.set(ApiMap.listUser, { http: { method: 'GET', uri: '/user', base: ApiMap.MAIN_BASE }, ws: { action: 'user/list', response: { bodyKey: 'users' } } });
apiMap.set(ApiMap.countUser, { http: { method: 'GET', uri: '/user/count', base: ApiMap.MAIN_BASE }, ws: { action: 'user/count', response: [`count`] } });
apiMap.set(ApiMap.getUser, { http: { method: 'GET', uri: '/user/{userId}', base: ApiMap.MAIN_BASE }, ws: { action: 'user/get', response: { bodyKey: 'user' } } });
apiMap.set(ApiMap.addUser, { http: { method: 'POST', uri: '/user', base: ApiMap.MAIN_BASE }, ws: { action: 'user/insert', bodyKey: 'user', response: { bodyKey: 'user' } } });
apiMap.set(ApiMap.updateUser, { http: { method: 'PUT', uri: '/user/{userId}', base: ApiMap.MAIN_BASE }, ws: { action: 'user/update', bodyKey: 'user', response: null } });
apiMap.set(ApiMap.deleteUser, { http: { method: 'DELETE', uri: '/user/{userId}', base: ApiMap.MAIN_BASE }, ws: { action: 'user/delete', response: null } });
apiMap.set(ApiMap.getCurrentUser, { http: { method: 'GET', uri: '/user/current', base: ApiMap.MAIN_BASE }, ws: { action: 'user/getCurrent', response: { bodyKey: 'current' } } });
apiMap.set(ApiMap.updateCurrentUser, { http: { method: 'PUT', uri: '/user/current', base: ApiMap.MAIN_BASE }, ws: { action: 'user/updateCurrent', bodyKey: 'user', response: null } });
apiMap.set(ApiMap.getUserDeviceTypes, { http: { method: 'GET', uri: '/user/{userId}/devicetype', base: ApiMap.MAIN_BASE } });
apiMap.set(ApiMap.unassignAllDeviceTypes, { http: { method: 'DELETE', uri: '/user/{userId}/devicetype/all', base: ApiMap.MAIN_BASE } });
apiMap.set(ApiMap.assignAllDeviceTypes, { http: { method: 'PUT', uri: '/user/{userId}/devicetype/all', base: ApiMap.MAIN_BASE } });
apiMap.set(ApiMap.unassignDeviceType, { http: { method: 'DELETE', uri: '/user/{userId}/devicetype/{deviceTypeId}', base: ApiMap.MAIN_BASE } });
apiMap.set(ApiMap.getUserDeviceType, { http: { method: 'GET', uri: '/user/{userId}/devicetype/{deviceTypeId}', base: ApiMap.MAIN_BASE } });
apiMap.set(ApiMap.assignDeviceType, { http: { method: 'PUT', uri: '/user/{userId}/devicetype/{deviceTypeId}', base: ApiMap.MAIN_BASE } });
apiMap.set(ApiMap.getUserNetwork, { http: { method: 'GET', uri: '/user/{userId}/network/{networkId}', base: ApiMap.MAIN_BASE }, ws: { action: 'user/getNetwork', response: { bodyKey: 'network' } } });
apiMap.set(ApiMap.assignNetwork, { http: { method: 'PUT', uri: '/user/{userId}/network/{networkId}', base: ApiMap.MAIN_BASE }, ws: { action: 'user/assignNetwork', response: null } });
apiMap.set(ApiMap.unassignNetwork, { http: { method: 'DELETE', uri: '/user/{userId}/network/{networkId}', base: ApiMap.MAIN_BASE }, ws: { action: 'user/unassignNetwork', response: null } });

apiMap.set(ApiMap.listPlugin, { http: { method: 'GET', uri: '/plugin', base: ApiMap.PLUGIN_BASE } });
apiMap.set(ApiMap.countPlugin, { http: { method: 'GET', uri: '/plugin/count', base: ApiMap.PLUGIN_BASE } });
apiMap.set(ApiMap.registerPlugin, { http: { method: 'POST', uri: '/plugin', base: ApiMap.PLUGIN_BASE } });
apiMap.set(ApiMap.deletePlugin, { http: { method: 'DELETE', uri: '/plugin', base: ApiMap.PLUGIN_BASE } });
apiMap.set(ApiMap.updatePlugin, { http: { method: 'PUT', uri: '/plugin', base: ApiMap.PLUGIN_BASE } });

module.exports = ApiMap;

},{"../../error/NoApiError":37,"../../error/UnsupportedApiTransportError":40,"./HttpApiResolver":34,"./WebSocketApiResolver":35}],34:[function(require,module,exports){
const format = require("string-template");
const queryString = require('query-string');

/**
 * HttpApiResolver
 */
class HttpApiResolver {

    /**
     * Builds URL
     * @param {string} base - base URI
     * @param {object} parameters - URI parameters
     * @returns {string}
     */
    static buildUrl(base, parameters = {}) {
        const pathRegex = /[^{}]+(?=\})/g;
        const pathParameterKeys = pathRegex.test(base) ? base.match(pathRegex) : [];
        const pathParameters = {};
        const queryParameters = {};
        Object.keys(parameters).forEach(key => {
            if (pathParameterKeys.includes(key)) {
                pathParameters[key] = parameters[key];
            } else {
                queryParameters[key] = parameters[key];
            }
        });

        const stringParameters = queryString.stringify(queryParameters);
        const url = format(base, pathParameters);

        return stringParameters ? `${url}?${stringParameters}` : url;
    }

    /**
     * Normalaizes response
     * @param {object} response
     * @returns {{*}} - Normalized response
     */
    static normalizeResponse(response) {
        if (response.error) {
            throw response.message;
        }

        return response;
    }

    /**
     * @param {object} options
     * @param {string} options.method
     * @param {string} options.uri
     * @param {string} options.base
     * @param {boolean} options.subscription
     * @param {boolean} options.unsubscription
     */
    constructor({ method, uri, base, subscription, unsubscription, noAuth }) {
        const me = this;

        me.method = method;
        me.uri = uri;
        me.base = base;
        me.subscription = subscription;
        me.unsubscription = unsubscription;
        me.noAuth = noAuth;
    }

    /**
     * Builds request
     * @param {object} parameters
     * @param {object} body
     * @returns {{method: *, endpoint: string}}
     */
    build(parameters, body) {
        const me = this;
        let result;

        if (me.unsubscription === true) {
            result = {
                noAuth: me.noAuth,
                unsubscription: me.unsubscription,
                body: {
                    subscriptionId: parameters.subscriptionId
                }
            };
        } else {
            result = {
                noAuth: me.noAuth,
                method: me.method,
                endpoint: HttpApiResolver.buildUrl(me.uri, parameters),
                base: me.base,
                subscription: me.subscription
            };

            if (body) {
                result.body = body;
            }
        }

        return result;
    }
}

module.exports = HttpApiResolver;

},{"query-string":10,"string-template":15}],35:[function(require,module,exports){
const Utils = require(`../../utils/Utils`);

/**
 * WebSocketApiResolver
 */
class WebSocketApiResolver {

    /**
     * Normalaizes response
     * @param {object} response - Response
     * @param {object} normalizationObject -  Normalization object
     * @returns {{}} - Normalized response
     */
    static normalizeResponse(response, normalizationObject) {
        let result = {};

        if (response.status === "error") {
            throw response.error;
        }

        if (normalizationObject) {
            if (normalizationObject.length) {
                normalizationObject.forEach(responseField => result[responseField] = response[responseField]);
            } else if (normalizationObject.bodyKey) {
                result = response[normalizationObject.bodyKey];
            }
        } else if (normalizationObject !== null) {
            result = response;
        }

        return result;
    }

    /**
     * @param action
     * @param bodyKey
     */
    constructor({ action, bodyKey }) {
        const me = this;

        me.action = action;
        me.bodyKey = bodyKey;
    }

    /**
     * Builds request
     * @param {object} parameters
     * @param {object} body
     * @returns {{action: *}}
     */
    build(parameters, body) {
        const me = this;
        const result = Utils.isObjectEmpty(parameters) && !me.bodyKey ? Object.assign({}, body) : Object.assign({}, parameters);

        result.action = me.action;

        if (body && me.bodyKey) {
            result[me.bodyKey] = body;
        }

        return result;
    }
}

module.exports = WebSocketApiResolver;

},{"../../utils/Utils":79}],36:[function(require,module,exports){
/**
 * InvalidCredentialsError class
 */
class InvalidCredentialsError extends Error {

  /**
   * Creates new InvalidCredentialsError
   */
  constructor(message) {
    super();

    this.message = `Invalid credentials error during attempt to authenticate. Error: ${message}`;
  }
}

module.exports = InvalidCredentialsError;

},{}],37:[function(require,module,exports){
/**
 * NoApiError class
 */
class NoApiError extends Error {

  /**
   * Creates new NoApiError
   */
  constructor() {
    super();

    this.message = `No API selected.\nPlease, choose one according to documentation.`;
  }
}

module.exports = NoApiError;

},{}],38:[function(require,module,exports){
/**
 * NoAuthenticationCredentials class
 */
class NoAuthenticationCredentials extends Error {

  /**
   * Creates new NoAuthenticationCredentials
   */
  constructor() {
    super();

    this.message = `No authentication credentials provided.\nPlease, use credentials provided in documentation.`;
  }
}

module.exports = NoAuthenticationCredentials;

},{}],39:[function(require,module,exports){
/**
 * ReconnectionAttemptFailedError class
 */
class ReconnectionAttemptFailedError extends Error {

  /**
   * Creates new InvalidCredentialsError
   */
  constructor(attempt) {
    super();

    this.message = `Reconnection attempt number ${attempt} is failed`;
  }
}

module.exports = ReconnectionAttemptFailedError;

},{}],40:[function(require,module,exports){
/**
 * UnsupportedApiTransportError class
 */
class UnsupportedApiTransportError extends Error {

  /**
   * Creates new UnsupportedApiTransportError
   */
  constructor({ key, transport }) {
    super();

    this.message = `${key} API is not supported by the ${transport} transport.`;
  }
}

module.exports = UnsupportedApiTransportError;

},{}],41:[function(require,module,exports){
/**
 * UnsupportedTransportError class
 */
class UnsupportedTransportError extends Error {

  /**
   * Creates new UnsupportedTransportError
   */
  constructor() {
    super();

    this.message = `You are trying to use unsupported transport type.\nPlease, use one of provided in documentation.`;
  }
}

module.exports = UnsupportedTransportError;

},{}],42:[function(require,module,exports){
/**
 * WebSocketError class
 */
class WebSocketError extends Error {

  /**
   * Creates new WebSocketError
   */
  constructor(error) {
    super();

    this.message = `Error using WebSocket.\nPlease, check server URL or try again later.\n${error.message}`;
  }
}

module.exports = WebSocketError;

},{}],43:[function(require,module,exports){
/**
 * BaseModel class
 */
class BaseModel {

  /**
   * Returns instance as a plain JS object
   * @returns {Object}
   */
  toObject() {
    console.warn(`The method "toObject" should be implemented in nested classes`);

    return {};
  }

  /**
   * Returns a stringified instance
   * @returns {string}
   */
  toString() {
    return JSON.stringify(this.toObject());
  }
}

module.exports = BaseModel;

},{}],44:[function(require,module,exports){
const BaseModel = require(`./BaseModel`);

/**
 * Configuration model
 */
class Configuration extends BaseModel {

    /**
     * Creates new Configuration model
     * @param {Object} options - model options object
     * @param {string} options.name - Configuration parameter name.
     * @param {string} options.value - Configuration parameter value.
     */
    constructor({ name, value, entityVersion } = {}) {
        super();

        this.name = name;
        this.value = value;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get value() {
        return this._value;
    }

    set value(value) {
        this._value = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            name: this.name,
            value: this.value,
            entityVersion: this.entityVersion
        };
    }
}

module.exports = Configuration;

},{"./BaseModel":43}],45:[function(require,module,exports){
const BaseModel = require(`./BaseModel`);

/**
 * Device model
 */
class Device extends BaseModel {

    /**
     * Creates new Device model
     * @param {object} options - model options object
     * @param {string} options.id - Device unique identifier
     * @param {string} options.name - Device display name
     * @param {object} options.data - Device data, a JSON object with an arbitrary structure
     * @param {number} options.networkId - Associated network id
     * @param {number} options.deviceTypeId - Associated deviceType id
     * @param {boolean} options.isBlocked - Indicates whether device is isBlocked
     */
    constructor({ id, name, data, networkId, deviceTypeId, isBlocked } = {}) {
        super();

        this.id = id;
        this.name = name;
        this.data = data;
        this.networkId = networkId;
        this.deviceTypeId = deviceTypeId;
        this.isBlocked = isBlocked;
    }

    get id() {
        return this._id;
    }

    set id(value) {
        this._id = value;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get data() {
        return this._data;
    }

    set data(value) {
        this._data = value;
    }

    get networkId() {
        return this._networkId;
    }

    set networkId(value) {
        this._networkId = value;
    }

    get deviceTypeId() {
        return this._deviceTypeId;
    }

    set deviceTypeId(value) {
        this._deviceTypeId = value;
    }

    get isBlocked() {
        return this._isBlocked;
    }

    set isBlocked(value) {
        this._isBlocked = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            id: this.id,
            name: this.name,
            data: this.data,
            networkId: this.networkId,
            deviceTypeId: this.deviceTypeId,
            isBlocked: this.isBlocked
        };
    }
}

module.exports = Device;

},{"./BaseModel":43}],46:[function(require,module,exports){
const BaseModel = require(`./BaseModel`);

/**
 * DeviceCommand model
 */
class DeviceCommand extends BaseModel {

    /**
     * Creates new DeviceCommand model
     * @param {object} options - model options object
     * @param {number} options.id - Command identifier
     * @param {string} options.command - Command name
     * @param {string} options.timestamp - Command UTC datetime (yyyy-MM-dd'T'HH:mm:ss.SSS ISO 8601)
     * @param {string} options.lastUpdated - Last command update UTC datetime (yyyy-MM-dd'T'HH:mm:ss.SSS ISO 8601)
     * @param {number} options.userId - Associated user identifier
     * @param {string} options.deviceId - Device unique identifier
     * @param {number} options.networkId - Network unique identifier
     * @param {number} options.deviceTypeId - DeviceType unique identifier
     * @param {object} options.parameters - Command parameters, a JSON object with an arbitrary structure
     * @param {number} options.lifetime - Command lifetime, a number of seconds until this command expires
     * @param {string} options.status - Command status, as reported by device or related infrastructure
     * @param {object} options.result - Command execution result, an optional value that could be provided by device
     */
    constructor({ id, command, timestamp, lastUpdated, userId, deviceId, networkId,
        deviceTypeId, parameters, lifetime, status, result } = {}) {
        super();

        this.id = id;
        this.command = command;
        this.timestamp = timestamp;
        this.lastUpdated = lastUpdated;
        this.userId = userId;
        this.deviceId = deviceId;
        this.networkId = networkId;
        this.deviceTypeId = deviceTypeId;
        this.parameters = parameters;
        this.lifetime = lifetime;
        this.status = status;
        this.result = result;
    }

    get id() {
        return this._id;
    }

    set id(value) {
        this._id = value;
    }

    get command() {
        return this._command;
    }

    set command(value) {
        this._command = value;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get notification() {
        return this._notification;
    }

    set notification(value) {
        this._notification = value;
    }

    get timestamp() {
        return this._timestamp;
    }

    set timestamp(value) {
        this._timestamp = value;
    }

    get lastUpdated() {
        return this._lastUpdated;
    }

    set lastUpdated(value) {
        this._lastUpdated = value;
    }

    get userId() {
        return this._userId;
    }

    set userId(value) {
        this._userId = value;
    }

    get deviceId() {
        return this._deviceId;
    }

    set deviceId(value) {
        this._deviceId = value;
    }

    get networkId() {
        return this._networkId;
    }

    set networkId(value) {
        this._networkId = value;
    }

    get deviceTypeId() {
        return this._deviceTypeId;
    }

    set deviceTypeId(value) {
        this._deviceTypeId = value;
    }

    get parameters() {
        return this._parameters;
    }

    set parameters(value) {
        this._parameters = value;
    }

    get lifetime() {
        return this._lifetime;
    }

    set lifetime(value) {
        this._lifetime = value;
    }

    get status() {
        return this._status;
    }

    set status(value) {
        this._status = value;
    }

    get result() {
        return this._result;
    }

    set result(value) {
        this._result = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            id: this.id,
            command: this.command,
            timestamp: this.timestamp,
            lastUpdated: this.lastUpdated,
            userId: this.userId,
            deviceId: this.deviceId,
            networkId: this.networkId,
            deviceTypeId: this.deviceTypeId,
            parameters: this.parameters,
            lifetime: this.lifetime,
            status: this.status,
            result: this.result
        };
    }
}

module.exports = DeviceCommand;

},{"./BaseModel":43}],47:[function(require,module,exports){
const BaseModel = require(`./BaseModel`);

/**
 * DeviceNotification model
 */
class DeviceNotification extends BaseModel {

    /**
     * Creates new DeviceNotification model
     * @param {object} options - model options object
     * @param {number} options.id - Notification identifier
     * @param {string} options.deviceId - Device unique identifier
     * @param {number} options.networkId - Network unique identifier
     * @param {number} options.deviceTypeId - Device type unique identifier
     * @param {string} options.notification - Notification name
     * @param {string} options.timestamp - Notification UTC datetime (yyyy-MM-dd'T'HH:mm:ss.SSS ISO 8601)
     * @param {object} options.parameters - Notification parameters, a JSON object with an arbitrary structure
     */
    constructor({ id, deviceId, networkId, deviceTypeId, notification, timestamp, parameters } = {}) {
        super();

        this.id = id;
        this.deviceId = deviceId;
        this.networkId = networkId;
        this.deviceTypeId = deviceTypeId;
        this.notification = notification;
        this.timestamp = timestamp;
        this.parameters = parameters;
    }

    get id() {
        return this._id;
    }

    set id(value) {
        this._id = value;
    }

    get deviceId() {
        return this._deviceId;
    }

    set deviceId(value) {
        this._deviceId = value;
    }

    get networkId() {
        return this._networkId;
    }

    set networkId(value) {
        this._networkId = value;
    }

    get deviceTypeId() {
        return this._deviceTypeId;
    }

    set deviceTypeId(value) {
        this._deviceTypeId = value;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get notification() {
        return this._notification;
    }

    set notification(value) {
        this._notification = value;
    }

    get timestamp() {
        return this._timestamp;
    }

    set timestamp(value) {
        this._timestamp = value;
    }

    get parameters() {
        return this._parameters;
    }

    set parameters(value) {
        this._parameters = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            id: this.id,
            deviceId: this.deviceId,
            networkId: this.networkId,
            deviceTypeId: this.deviceTypeId,
            notification: this.notification,
            timestamp: this.timestamp,
            parameters: this.parameters
        };
    }
}

module.exports = DeviceNotification;

},{"./BaseModel":43}],48:[function(require,module,exports){
const BaseModel = require(`./BaseModel`);

/**
 * DeviceType model
 */
class DeviceType extends BaseModel {

    /**
     * Creates new DeviceType model
     * @param {object} options - model options object
     * @param {number} options.id - Device type identifier
     * @param {string} options.name - Device type name
     * @param {string} options.description - Device type description
     */
    constructor({ id, name, description } = {}) {
        super();

        this.id = id;
        this.name = name;
        this.description = description;
    }

    get id() {
        return this._id;
    }

    set id(value) {
        this._id = value;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get description() {
        return this._description;
    }

    set description(value) {
        this._description = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            id: this.id,
            name: this.name,
            description: this.description
        };
    }
}

module.exports = DeviceType;

},{"./BaseModel":43}],49:[function(require,module,exports){
const BaseModel = require(`./BaseModel`);

/**
 * Network model
 */
class Network extends BaseModel {

    /**
     * Creates new Network model
     * @param {object} options - model options object
     * @param {number} options.id - Network identifier
     * @param {string} options.name - Network name
     * @param {string} options.description - Network description
     */
    constructor({ id, name, description } = {}) {
        super();

        this.id = id;
        this.name = name;
        this.description = description;
    }

    get id() {
        return this._id;
    }

    set id(value) {
        this._id = value;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get description() {
        return this._description;
    }

    set description(value) {
        this._description = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            id: this.id,
            name: this.name,
            description: this.description
        };
    }
}

module.exports = Network;

},{"./BaseModel":43}],50:[function(require,module,exports){
const BaseModel = require(`./BaseModel`);

/**
 * Plugin model
 */
class Plugin extends BaseModel {

    /**
     * Creates new Plugin model
     * @param {object} options - model options object
     * @param {id} options.id - Plgin unique idnetifier
     * @param {string} options.name - Plugin name
     * @param {string} options.description - Plugin description
     * @param {string} options.topicName - Plugin topic name
     * @param {string} options.filter - Plugin filter
     * @param {string} options.status - Plugin status
     * @param {string} options.subscriptionId - Plugin subscribtion id
     * @param {number} options.userId - Plugin user id
     * @param {object} options.parameters - Json object with parameters
     */
    constructor({ id, name, description, topicName, filter, status, subscriptionId, userId, parameters } = {}) {
        super();

        this.id = id;
        this.name = name;
        this.description = description;
        this.topicName = topicName;
        this.filter = filter;
        this.status = status;
        this.subscriptionId = subscriptionId;
        this.userId = userId;
        this.parameters = parameters;
    }

    get id() {
        return this._id;
    }

    set id(value) {
        this._id = value;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get description() {
        return this._description;
    }

    set description(value) {
        this._description = value;
    }

    get topicName() {
        return this._topicName;
    }

    set topicName(value) {
        this._topicName = value;
    }

    get filter() {
        return this._filter;
    }

    set filter(value) {
        this._filter = value;
    }

    get status() {
        return this._status;
    }

    set status(value) {
        this._status = value;
    }

    get subscriptionId() {
        return this._subscriptionId;
    }

    set subscriptionId(value) {
        this._subscriptionId = value;
    }

    get userId() {
        return this._userId;
    }

    set userId(value) {
        this._userId = value;
    }

    get parameters() {
        return this._parameters;
    }

    set parameters(value) {
        this._parameters = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            id: this.id,
            name: this.name,
            description: this.description,
            topicName: this.topicName,
            filter: this.filter,
            status: this.status,
            subscriptionId: this.subscriptionId,
            userId: this.userId,
            parameters: this.parameters
        };
    }
}

module.exports = Plugin;

},{"./BaseModel":43}],51:[function(require,module,exports){
const BaseModel = require(`./BaseModel`);

/**
 * PluginToken model
 */
class PluginToken extends BaseModel {

    /**
     * Creates new PluginToken model
     * @param {object} options - model options object
     * @param {Array} options.actions - Plugin Token actions
     * @param {string} options.expiration - Plugin expiration
     * @param {number} options.type - Plugin type
     * @param {string} options.topicName - Plugin topic name
     */
    constructor({ actions, expiration, type, topicName } = {}) {
        super();

        this.actions = actions;
        this.expiration = expiration;
        this.type = type;
        this.topicName = topicName;
    }

    get actions() {
        return this._actions;
    }

    set actions(value) {
        this._actions = value;
    }

    get expiration() {
        return this._expiration;
    }

    set expiration(value) {
        this._expiration = value;
    }

    get type() {
        return this._type;
    }

    set type(value) {
        this._type = value;
    }

    get topicName() {
        return this._topicName;
    }

    set topicName(value) {
        this._topicName = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            a: this.actions,
            e: this.expiration,
            t: this.type,
            tpc: this.topicName
        };
    }
}

module.exports = PluginToken;

},{"./BaseModel":43}],52:[function(require,module,exports){
const BaseModel = require(`./BaseModel`);

/**
 * User model
 */
class User extends BaseModel {

    /**
     * Creates new User model
     * @param {object} options - model options object
     * @param {numebr} options.id - User identifier
     * @param {string} options.login - User login using during authentication
     * @param {number} options.role - User role. Available values: 0: Administrator role, 1: Client role.
     * @param {number} options.status - User status. Available values: 0: The user is active, 1: The user has been locked out due to invalid login attempts, 2: The user has been disabled
     * @param {string} options.lastLogin User last login timestamp (UTC)
     * @param {object} options.data - User data, a JSON object with an arbitrary structure
     * @param {string} options.password - User Password
     * @param {boolean} options.introReviewed - Indicates if user reviewed an intro
     * @param {boolean} options.allDeviceTypesAvailable - Is all device types awailable
     */
    constructor({ id, login, role, status, lastLogin, data, password, introReviewed, allDeviceTypesAvailable } = {}) {
        super();

        this.id = id;
        this.login = login;
        this.role = role;
        this.status = status;
        this.lastLogin = lastLogin;
        this.data = data;
        this.password = password;
        this.introReviewed = introReviewed;
        this.allDeviceTypesAvailable = allDeviceTypesAvailable;
    }

    get id() {
        return this._id;
    }

    set id(value) {
        this._id = value;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get login() {
        return this._login;
    }

    set login(value) {
        this._login = value;
    }

    get role() {
        return this._role;
    }

    set role(value) {
        this._role = value;
    }

    get status() {
        return this._status;
    }

    set status(value) {
        this._status = value;
    }

    get lastLogin() {
        return this._lastLogin;
    }

    set lastLogin(value) {
        this._lastLogin = value;
    }

    get data() {
        return this._data;
    }

    set data(value) {
        this._data = value;
    }

    get password() {
        return this._password;
    }

    set password(value) {
        this._password = value;
    }

    get introReviewed() {
        return this._introReviewed;
    }

    set introReviewed(value) {
        this._introReviewed = value;
    }

    get allDeviceTypesAvailable() {
        return this._allDeviceTypesAvailable;
    }

    set allDeviceTypesAvailable(value) {
        this._allDeviceTypesAvailable = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            id: this.id,
            login: this.login,
            role: this.role,
            status: this.status,
            lastLogin: this.lastLogin,
            data: this.data,
            password: this.password,
            introReviewed: this.introReviewed,
            allDeviceTypesAvailable: this.allDeviceTypesAvailable
        };
    }
}

module.exports = User;

},{"./BaseModel":43}],53:[function(require,module,exports){
const BaseModel = require(`./BaseModel`);

/**
 * UserToken model
 */
class UserToken extends BaseModel {

    /**
     * Creates new UserToken model
     * @param {object} options - model options object
     * @param {number} options.userId - User id
     * @param {Array} options.actions - User Actions
     * @param {Array} options.networkIds - Network id's
     * @param {Array} options.deviceTypeIds - Devicetype id's
     * @param {string} options.expiration - Token expiration datetme
     */
    constructor({ userId, actions, networkIds, deviceTypeIds, expiration, refreshExpiration } = {}) {
        super();

        this.userId = userId;
        this.actions = actions;
        this.networkIds = networkIds;
        this.deviceTypeIds = deviceTypeIds;
        this.expiration = expiration;
        this.refreshExpiration = refreshExpiration;
    }

    get userId() {
        return this._userId;
    }

    set userId(value) {
        this._userId = value;
    }

    get actions() {
        return this._actions;
    }

    set actions(value) {
        this._actions = value;
    }

    get networkIds() {
        return this._networkIds;
    }

    set networkIds(value) {
        this._networkIds = value;
    }

    get deviceTypeIds() {
        return this._deviceTypeIds;
    }

    set deviceTypeIds(value) {
        this._deviceTypeIds = value;
    }

    get expiration() {
        return this._expiration;
    }

    set expiration(value) {
        this._expiration = value;
    }

    get refreshExpiration() {
        return this._refreshExpiration;
    }

    set refreshExpiration(value) {
        this._refreshExpiration = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            userId: this.userId,
            actions: this.actions,
            networkIds: this.networkIds,
            deviceTypeIds: this.deviceTypeIds,
            expiration: this.expiration,
            refreshExpiration: this.refreshExpiration
        };
    }
}

module.exports = UserToken;

},{"./BaseModel":43}],54:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * CommandGetQuery class
 */
class CommandGetQuery extends BaseModel {

    /**
     * Creates new CommandGetQuery model
     * @param {object} options - model options object
     * @param {boolean} options.returnUpdatedCommands - Checks if updated commands should be returned
     */
    constructor({ returnUpdatedCommands = false } = {}) {
        super();

        this.returnUpdatedCommands = returnUpdatedCommands;
    }

    get returnUpdatedCommands() {
        return this._returnUpdatedCommands;
    }

    set returnUpdatedCommands(value) {
        this._returnUpdatedCommands = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            returnUpdatedCommands: this.returnUpdatedCommands
        };
    }
}

module.exports = CommandGetQuery;

},{"../BaseModel":43}],55:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * CommandListQuery class
 */
class CommandListQuery extends BaseModel {

    /**
     * Creates new CommandListQuery model
     * @param {object} options - model options object
     * @param {string} options.deviceId - Device ID
     * @param {string} options.start - Start timestamp
     * @param {string} options.end - End timestamp
     * @param {string} options.command - Command name
     * @param {string} options.status - Command status
     * @param {string} options.sortField - Sort field
     * @param {string} options.sortOrder - Sort order
     * @param {number} options.take - Limit param
     * @param {number} options.skip - Skip param
     */
    constructor({ deviceId, start, end, command, status, sortField, sortOrder, take, skip } = {}) {
        super();

        this.deviceId = deviceId;
        this.start = start;
        this.end = end;
        this.command = command;
        this.status = status;
        this.sortField = sortField;
        this.sortOrder = sortOrder;
        this.take = take;
        this.skip = skip;
    }

    get deviceId() {
        return this._deviceId;
    }

    set deviceId(value) {
        this._deviceId = value;
    }

    get start() {
        return this._start;
    }

    set start(value) {
        this._start = value;
    }

    get end() {
        return this._end;
    }

    set end(value) {
        this._end = value;
    }

    get command() {
        return this._command;
    }

    set command(value) {
        this._command = value;
    }

    get status() {
        return this._status;
    }

    set status(value) {
        this._status = value;
    }

    get sortField() {
        return this._sortField;
    }

    set sortField(value) {
        this._sortField = value;
    }

    get sortOrder() {
        return this._sortOrder;
    }

    set sortOrder(value) {
        this._sortOrder = value;
    }

    get take() {
        return this._take;
    }

    set take(value) {
        this._take = value;
    }

    get skip() {
        return this._skip;
    }

    set skip(value) {
        this._skip = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            deviceId: this.deviceId,
            start: this.start,
            end: this.end,
            command: this.command,
            status: this.status,
            sortField: this.sortField,
            sortOrder: this.sortOrder,
            take: this.take,
            skip: this.skip
        };
    }
}

module.exports = CommandListQuery;

},{"../BaseModel":43}],56:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * CommandPollManyQuery class
 */
class CommandPollManyQuery extends BaseModel {

    /**
     * Creates new CommandPollManyQuery model
     * @param {object} options - model options object
     * @param {string} options.deviceIds - List of device IDs
     * @param {string} options.networkIds - List of network IDs
     * @param {string} options.deviceTypeIds - List of devicetype IDs
     * @param {string} options.names - Command names
     * @param {string} options.timestamp - Timestamp to start from
     * @param {number} options.waitTimeout - Wait timeout in seconds
     * @param {number} options.limit - Limit number of commands
     */
    constructor({ deviceIds, networkIds, deviceTypeIds, names, timestamp, waitTimeout, limit } = {}) {
        super();

        this.deviceIds = deviceIds;
        this.networkIds = networkIds;
        this.deviceTypeIds = deviceTypeIds;
        this.names = names;
        this.timestamp = timestamp;
        this.waitTimeout = waitTimeout;
        this.limit = limit;
    }

    get deviceIds() {
        return this._deviceIds;
    }

    set deviceIds(value) {
        this._deviceIds = value;
    }

    get networkIds() {
        return this._networkIds;
    }

    set networkIds(value) {
        this._networkIds = value;
    }

    get deviceTypeIds() {
        return this._deviceTypeIds;
    }

    set deviceTypeIds(value) {
        this._deviceTypeIds = value;
    }

    get names() {
        return this._names;
    }

    set names(value) {
        this._names = value;
    }

    get timestamp() {
        return this._timestamp;
    }

    set timestamp(value) {
        this._timestamp = value;
    }

    get waitTimeout() {
        return this._waitTimeout;
    }

    set waitTimeout(value) {
        this._waitTimeout = value;
    }

    get limit() {
        return this._limit;
    }

    set limit(value) {
        this._limit = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            deviceIds: this.deviceIds,
            networkIds: this.networkIds,
            deviceTypeIds: this.deviceTypeIds,
            names: this.names,
            timestamp: this.timestamp,
            waitTimeout: this.waitTimeout,
            limit: this.limit
        };
    }
}

module.exports = CommandPollManyQuery;

},{"../BaseModel":43}],57:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * CommandPollQuery class
 */
class CommandPollQuery extends BaseModel {

    /**
     * Creates new CommandPollQuery model
     * @param {object} options - model options object
     * @param {string} options.deviceId - Device ID
     * @param {string} options.names - Command names
     * @param {number} options.timestamp - Timestamp to start from
     * @param {boolean} options.returnUpdatedCommands - Checks if updated commands should be returned
     * @param {number} options.waitTimeout - Wait timeout in seconds
     * @param {number} options.limit - Limit number of commands
     */
    constructor({ deviceId, names, timestamp, returnUpdatedCommands, waitTimeout, limit } = {}) {
        super();

        this.deviceId = deviceId;
        this.names = names;
        this.timestamp = timestamp;
        this.returnUpdatedCommands = returnUpdatedCommands;
        this.waitTimeout = waitTimeout;
        this.limit = limit;
    }

    get deviceId() {
        return this._deviceId;
    }

    set deviceId(value) {
        this._deviceId = value;
    }

    get names() {
        return this._names;
    }

    set names(value) {
        this._names = value;
    }

    get timestamp() {
        return this._timestamp;
    }

    set timestamp(value) {
        this._timestamp = value;
    }

    get returnUpdatedCommands() {
        return this._returnUpdatedCommands;
    }

    set returnUpdatedCommands(value) {
        this._returnUpdatedCommands = value;
    }

    get waitTimeout() {
        return this._waitTimeout;
    }

    set waitTimeout(value) {
        this._waitTimeout = value;
    }

    get limit() {
        return this._limit;
    }

    set limit(value) {
        this._limit = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            deviceId: this.deviceId,
            names: this.names,
            timestamp: this.timestamp,
            returnUpdatedCommands: this.returnUpdatedCommands,
            waitTimeout: this.waitTimeout,
            limit: this.limit
        };
    }
}

module.exports = CommandPollQuery;

},{"../BaseModel":43}],58:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * CommandWaitQuery class
 */
class CommandWaitQuery extends BaseModel {

    /**
     * Creates new CommandWaitQuery model
     * @param {Object} options - model options object
     * @param {Number} options.waitTimeout - wait timeout (sec)
     */
    constructor({ waitTimeout } = {}) {
        super();

        this.waitTimeout = waitTimeout;
    }

    get waitTimeout() {
        return this._waitTimeout;
    }

    set waitTimeout(value) {
        this._waitTimeout = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return { waitTimeout: this.waitTimeout };
    }
}

module.exports = CommandWaitQuery;

},{"../BaseModel":43}],59:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * DeviceCountQuery class
 */
class DeviceCountQuery extends BaseModel {

    /**
     * Creates new DeviceCountQuery model
     * @param {object} options - model options object
     * @param {string} options.name - Filter by device name
     * @param {string} options.namePattern - Filter by device name pattern. In pattern wildcards '%' and '_' can be used
     * @param {number} options.networkId - Filter by associated network identifier
     * @param {string} options.networkName - Filter by associated network name
     */
    constructor({ name, namePattern, networkId, networkName } = {}) {
        super();

        this.name = name;
        this.namePattern = namePattern;
        this.networkId = networkId;
        this.networkName = networkName;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get namePattern() {
        return this._namePattern;
    }

    set namePattern(value) {
        this._namePattern = value;
    }

    get networkId() {
        return this._networkId;
    }

    set networkId(value) {
        this._networkId = value;
    }

    get networkName() {
        return this._networkName;
    }

    set networkName(value) {
        this._networkName = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            name: this.name,
            namePattern: this.namePattern,
            networkId: this.networkId,
            networkName: this.networkName
        };
    }
}

module.exports = DeviceCountQuery;

},{"../BaseModel":43}],60:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * DeviceListQuery class
 */
class DeviceListQuery extends BaseModel {

    /**
     * Creates new DeviceListQuery model
     * @param {object} options - model options object
     * @param {string} options.name - Filter by device name
     * @param {string} options.namePattern - Filter by device name pattern. In pattern wildcards '%' and '_' can be used
     * @param {number} options.networkId - Filter by associated network identifier
     * @param {string} options.networkName - Filter by associated network name
     * @param {string} options.sortField - Result list sort field
     * @param {string} options.sortOrder - Result list sort order. The sortField should be specified
     * @param {number} options.take - Number of records to take from the result list
     * @param {number} options.skip - Number of records to skip from the result list
     */
    constructor({ name, namePattern, networkId, networkName, sortField, sortOrder, take, skip } = {}) {
        super();

        this.name = name;
        this.namePattern = namePattern;
        this.networkId = networkId;
        this.networkName = networkName;
        this.sortField = sortField;
        this.sortOrder = sortOrder;
        this.take = take;
        this.skip = skip;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get namePattern() {
        return this._namePattern;
    }

    set namePattern(value) {
        this._namePattern = value;
    }

    get networkId() {
        return this._networkId;
    }

    set networkId(value) {
        this._networkId = value;
    }

    get networkName() {
        return this._networkName;
    }

    set networkName(value) {
        this._networkName = value;
    }

    get sortField() {
        return this._sortField;
    }

    set sortField(value) {
        this._sortField = value;
    }

    get sortOrder() {
        return this._sortOrder;
    }

    set sortOrder(value) {
        this._sortOrder = value;
    }

    get take() {
        return this._take;
    }

    set take(value) {
        this._take = value;
    }

    get skip() {
        return this._skip;
    }

    set skip(value) {
        this._skip = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            name: this.name,
            namePattern: this.namePattern,
            networkId: this.networkId,
            networkName: this.networkName,
            sortField: this.sortField,
            sortOrder: this.sortOrder,
            take: this.take,
            skip: this.skip
        };
    }
}

module.exports = DeviceListQuery;

},{"../BaseModel":43}],61:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * DeviceTypeCountQuery class
 */
class DeviceTypeCountQuery extends BaseModel {

    /**
     * Creates new DeviceTypeCountQuery model
     * @param {object} options - model options object
     * @param {string} options.name - Filter by device type name
     * @param {string} options.namePattern - Filter by device type name pattern. In pattern wildcards '%' and '_' can be used
     */
    constructor({ name, namePattern } = {}) {
        super();

        this.name = name;
        this.namePattern = namePattern;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get namePattern() {
        return this._namePattern;
    }

    set namePattern(value) {
        this._namePattern = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            name: this.name,
            namePattern: this.namePattern
        };
    }
}

module.exports = DeviceTypeCountQuery;

},{"../BaseModel":43}],62:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * DeviceTypeDeleteQuery class
 */
class DeviceTypeDeleteQuery extends BaseModel {

    /**
     * Creates new DeviceTypeDeleteQuery model
     * @param {object} options - model options object
     * @param {string} options.deviceTypeId - deviceType's id
     * @param {boolean} options.force - flag for force delete
     */
    constructor({ deviceTypeId, force } = {}) {
        super();

        this.deviceTypeId = deviceTypeId;
        this.force = force;
    }

    get deviceTypeId() {
        return this._deviceTypeId;
    }

    set deviceTypeId(value) {
        this._deviceTypeId = value;
    }

    get force() {
        return this._force;
    }

    set force(value) {
        this._force = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            deviceTypeId: this.deviceTypeId,
            force: this.force
        };
    }
}

module.exports = DeviceTypeDeleteQuery;

},{"../BaseModel":43}],63:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * DeviceTypeListQuery class
 */
class DeviceTypeListQuery extends BaseModel {

    /**
     * Creates new DeviceTypeListQuery model
     * @param {object} options - model options object
     * @param {string} options.name - Filter by device type name
     * @param {string} options.namePattern - Filter by device type name pattern. In pattern wildcards '%' and '_' can be used
     * @param {string} options.sortField - Result list sort field
     * @param {string} options.sortOrder - Result list sort order. The sortField should be specified
     * @param {number} options.take - Number of records to take from the result list
     * @param {number} options.skip - Number of records to skip from the result list
     */
    constructor({ name, namePattern, sortField, sortOrder, take, skip } = {}) {
        super();

        this.name = name;
        this.namePattern = namePattern;
        this.sortField = sortField;
        this.sortOrder = sortOrder;
        this.take = take;
        this.skip = skip;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get namePattern() {
        return this._namePattern;
    }

    set namePattern(value) {
        this._namePattern = value;
    }

    get sortField() {
        return this._sortField;
    }

    set sortField(value) {
        this._sortField = value;
    }

    get sortOrder() {
        return this._sortOrder;
    }

    set sortOrder(value) {
        this._sortOrder = value;
    }

    get take() {
        return this._take;
    }

    set take(value) {
        this._take = value;
    }

    get skip() {
        return this._skip;
    }

    set skip(value) {
        this._skip = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            name: this.name,
            namePattern: this.namePattern,
            sortField: this.sortField,
            sortOrder: this.sortOrder,
            take: this.take,
            skip: this.skip
        };
    }
}

module.exports = DeviceTypeListQuery;

},{"../BaseModel":43}],64:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * NetworkCountQuery class
 */
class NetworkCountQuery extends BaseModel {

    /**
     * Creates new NetworkCountQuery model
     * @param {object} options - model options object
     * @param {string} options.name - Filter by device type name
     * @param {string} options.namePattern - Filter by device type name pattern. In pattern wildcards '%' and '_' can be used
     */
    constructor({ name, namePattern } = {}) {
        super();

        this.name = name;
        this.namePattern = namePattern;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get namePattern() {
        return this._namePattern;
    }

    set namePattern(value) {
        this._namePattern = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            name: this.name,
            namePattern: this.namePattern
        };
    }
}

module.exports = NetworkCountQuery;

},{"../BaseModel":43}],65:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * NetworkDeleteQuery class
 */
class NetworkDeleteQuery extends BaseModel {

    /**
     * Creates new NetworkDeleteQuery model
     * @param {object} options - model options object
     * @param {string} options.networkId - network's id
     * @param {boolean} options.force - flag for force delete
     */
    constructor({ networkId, force } = {}) {
        super();

        this.networkId = networkId;
        this.force = force;
    }

    get networkId() {
        return this._networkId;
    }

    set networkId(value) {
        this._networkId = value;
    }

    get force() {
        return this._force;
    }

    set force(value) {
        this._force = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            networkId: this.networkId,
            force: this.force
        };
    }
}

module.exports = NetworkDeleteQuery;

},{"../BaseModel":43}],66:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * NetworkListQuery class
 */
class NetworkListQuery extends BaseModel {

    /**
     * Creates new NetworkListQuery model
     * @param {object} options - model options object
     * @param {string} options.name - Filter by device type name
     * @param {string} options.namePattern - Filter by device type name pattern. In pattern wildcards '%' and '_' can be used
     * @param {string} options.sortField - Result list sort field
     * @param {string} options.sortOrder - Result list sort order. The sortField should be specified
     * @param {number} options.take - Number of records to take from the result list
     * @param {number} options.skip - Number of records to skip from the result list
     */
    constructor({ name, namePattern, sortField, sortOrder, take, skip } = {}) {
        super();

        this.name = name;
        this.namePattern = namePattern;
        this.sortField = sortField;
        this.sortOrder = sortOrder;
        this.take = take;
        this.skip = skip;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get namePattern() {
        return this._namePattern;
    }

    set namePattern(value) {
        this._namePattern = value;
    }

    get sortField() {
        return this._sortField;
    }

    set sortField(value) {
        this._sortField = value;
    }

    get sortOrder() {
        return this._sortOrder;
    }

    set sortOrder(value) {
        this._sortOrder = value;
    }

    get take() {
        return this._take;
    }

    set take(value) {
        this._take = value;
    }

    get skip() {
        return this._skip;
    }

    set skip(value) {
        this._skip = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            name: this.name,
            namePattern: this.namePattern,
            sortField: this.sortField,
            sortOrder: this.sortOrder,
            take: this.take,
            skip: this.skip
        };
    }
}

module.exports = NetworkListQuery;

},{"../BaseModel":43}],67:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * NotificationListQuery class
 */
class NotificationListQuery extends BaseModel {

    /**
     * Creates new NotificationListQuery model
     * @param {object} options - model options object
     * @param {string} options.deviceId - Device ID
     * @param {string} options.start - Start timestamp
     * @param {string} options.end - End timestamp
     * @param {string} options.notification - Notification name
     * @param {string} options.sortField - Sort field
     * @param {string} options.sortOrder - Sort order
     * @param {number} options.take - Limit param
     * @param {number} options.skip - Skip param
     */
    constructor({ deviceId, start, end, notification, sortField, sortOrder, take, skip } = {}) {
        super();

        this.deviceId = deviceId;
        this.start = start;
        this.end = end;
        this.notification = notification;
        this.sortField = sortField;
        this.sortOrder = sortOrder;
        this.take = take;
        this.skip = skip;
    }

    get deviceId() {
        return this._deviceId;
    }

    set deviceId(value) {
        this._deviceId = value;
    }

    get start() {
        return this._start;
    }

    set start(value) {
        this._start = value;
    }

    get end() {
        return this._end;
    }

    set end(value) {
        this._end = value;
    }

    get notification() {
        return this._notification;
    }

    set notification(value) {
        this._notification = value;
    }

    get sortField() {
        return this._sortField;
    }

    set sortField(value) {
        this._sortField = value;
    }

    get sortOrder() {
        return this._sortOrder;
    }

    set sortOrder(value) {
        this._sortOrder = value;
    }

    get take() {
        return this._take;
    }

    set take(value) {
        this._take = value;
    }

    get skip() {
        return this._skip;
    }

    set skip(value) {
        this._skip = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            deviceId: this.deviceId,
            start: this.start,
            end: this.end,
            notification: this.notification,
            sortField: this.sortField,
            sortOrder: this.sortOrder,
            take: this.take,
            skip: this.skip
        };
    }
}

module.exports = NotificationListQuery;

},{"../BaseModel":43}],68:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * NotificationPollManyQuery class
 */
class NotificationPollManyQuery extends BaseModel {

    /**
     * Creates new NotificationPollManyQuery model
     * @param {object} options - model options object
     * @param {string} options.deviceIds - List of device IDs
     * @param {string} options.networkIds - List of network IDs
     * @param {string} options.deviceTypeIds - List of devicetype IDs
     * @param {string} options.names - Notification names
     * @param {string} options.timestamp - Timestamp to start from
     * @param {number} options.waitTimeout - Wait timeout in seconds
     */
    constructor({ deviceIds, networkIds, deviceTypeIds, names, timestamp, waitTimeout } = {}) {
        super();

        this.deviceIds = deviceIds;
        this.networkIds = networkIds;
        this.deviceTypeIds = deviceTypeIds;
        this.names = names;
        this.timestamp = timestamp;
        this.waitTimeout = waitTimeout;
    }

    get deviceIds() {
        return this._deviceIds;
    }

    set deviceIds(value) {
        this._deviceIds = value;
    }

    get networkIds() {
        return this._networkIds;
    }

    set networkIds(value) {
        this._networkIds = value;
    }

    get deviceTypeIds() {
        return this._deviceTypeIds;
    }

    set deviceTypeIds(value) {
        this._deviceTypeIds = value;
    }

    get names() {
        return this._names;
    }

    set names(value) {
        this._names = value;
    }

    get timestamp() {
        return this._timestamp;
    }

    set timestamp(value) {
        this._timestamp = value;
    }

    get waitTimeout() {
        return this._waitTimeout;
    }

    set waitTimeout(value) {
        this._waitTimeout = value;
    }

    /**
     *
     * @returns {Object}
     */
    toObject() {
        return {
            deviceIds: this.deviceIds,
            networkIds: this.networkIds,
            deviceTypeIds: this.deviceTypeIds,
            names: this.names,
            timestamp: this.timestamp,
            waitTimeout: this.waitTimeout
        };
    }
}

module.exports = NotificationPollManyQuery;

},{"../BaseModel":43}],69:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * NotificationPollQuery class
 */
class NotificationPollQuery extends BaseModel {

    /**
     * Creates new NotificationPollQuery model
     * @param {object} options - model options object
     * @param {string} options.deviceId - Device ID
     * @param {string} options.names - Notification names
     * @param {number} options.timestamp - Timestamp to start from
     * @param {number} options.waitTimeout - Wait timeout in seconds
     */
    constructor({ deviceId, names, timestamp, waitTimeout } = {}) {
        super();

        this.deviceId = deviceId;
        this.names = names;
        this.timestamp = timestamp;
        this.waitTimeout = waitTimeout;
    }

    get deviceId() {
        return this._deviceId;
    }

    set deviceId(value) {
        this._deviceId = value;
    }

    get names() {
        return this._names;
    }

    set names(value) {
        this._names = value;
    }

    get timestamp() {
        return this._timestamp;
    }

    set timestamp(value) {
        this._timestamp = value;
    }

    get waitTimeout() {
        return this._waitTimeout;
    }

    set waitTimeout(value) {
        this._waitTimeout = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            deviceId: this.deviceId,
            names: this.names,
            timestamp: this.timestamp,
            waitTimeout: this.waitTimeout
        };
    }
}

module.exports = NotificationPollQuery;

},{"../BaseModel":43}],70:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * PluginCountQuery class
 */
class PluginCountQuery extends BaseModel {

    /**
     * Creates new PluginCountQuery model
     * @param {object} options - model options object
     * @param {string} options.name - Filter by plugin name
     * @param {string} options.namePattern - Filter by plugin name pattern. In pattern wildcards '%' and '_' can be used
     * @param {string} options.topicName - Filter by plugin topic name
     * @param {number} options.status - Filter by plugin status
     * @param {number} options.userId - Filter by associated user identifier. Only admin can see other users' plugins
     */
    constructor({ name, namePattern, topicName, status, userId } = {}) {
        super();

        this.name = name;
        this.namePattern = namePattern;
        this.topicName = topicName;
        this.status = status;
        this.userId = userId;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get namePattern() {
        return this._namePattern;
    }

    set namePattern(value) {
        this._namePattern = value;
    }

    get topicName() {
        return this._topicName;
    }

    set topicName(value) {
        this._topicName = value;
    }

    get status() {
        return this._status;
    }

    set status(value) {
        this._status = value;
    }

    get userId() {
        return this._userId;
    }

    set userId(value) {
        this._userId = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            name: this.name,
            namePattern: this.namePattern,
            topicName: this.topicName,
            status: this.status,
            userId: this.userId
        };
    }
}

module.exports = PluginCountQuery;

},{"../BaseModel":43}],71:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * PluginListQuery class
 */
class PluginListQuery extends BaseModel {

    /**
     * Creates new PluginListQuery model
     * @param {object} options - model options object
     * @param {string} options.name - Filter by plugin name
     * @param {string} options.namePattern - Filter by plugin name pattern. In pattern wildcards '%' and '_' can be used
     * @param {string} options.topicName - Filter by plugin topic nathis.
     * @param {string} options.status - Filter by plugin status.
     * @param {number} options.userId - Filter by associated user identifier. Only admin can see other users' plugins
     * @param {string} options.sortField - Result list sort field
     * @param {string} options.sortOrder - Result list sort order. The sortField should be specified
     * @param {number} options.take - Number of records to take from the result list
     * @param {number} options.skip - Number of records to skip from the result list
     */
    constructor({ name, namePattern, topicName, status, userId, sortField, sortOrder, take, skip } = {}) {
        super();

        this.name = name;
        this.namePattern = namePattern;
        this.topicName = topicName;
        this.status = status;
        this.userId = userId;
        this.sortField = sortField;
        this.sortOrder = sortOrder;
        this.take = take;
        this.skip = skip;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get namePattern() {
        return this._namePattern;
    }

    set namePattern(value) {
        this._namePattern = value;
    }

    get topicName() {
        return this._topicName;
    }

    set topicName(value) {
        this._topicName = value;
    }

    get status() {
        return this._status;
    }

    set status(value) {
        this._status = value;
    }

    get userId() {
        return this._userId;
    }

    set userId(value) {
        this._userId = value;
    }

    get sortField() {
        return this._sortField;
    }

    set sortField(value) {
        this._sortField = value;
    }

    get sortOrder() {
        return this._sortOrder;
    }

    set sortOrder(value) {
        this._sortOrder = value;
    }

    get take() {
        return this._take;
    }

    set take(value) {
        this._take = value;
    }

    get skip() {
        return this._skip;
    }

    set skip(value) {
        this._skip = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            name: this.name,
            namePattern: this.namePattern,
            topicName: this.topicName,
            status: this.status,
            userId: this.userId,
            sortField: this.sortField,
            sortOrder: this.sortOrder,
            take: this.take,
            skip: this.skip
        };
    }
}

module.exports = PluginListQuery;

},{"../BaseModel":43}],72:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * PluginRegisterQuery class
 */
class PluginRegisterQuery extends BaseModel {

    /**
     * Creates new PluginRegisterQuery model
     * @param {object} options - model options object
     * @param {string} [options.deviceId] - Device device_id
     * @param {string} [options.networkIds] - Network ids
     * @param {string} [options.deviceTypeIds] - Device type ids
     * @param {string} [options.names] - Command/Notification names
     * @param {boolean} [options.returnCommands] - Checks if commands should be returned
     * @param {boolean} [options.returnUpdatedCommands] - Checks if updated commands should be returned
     * @param {boolean} [options.returnNotifications] - Checks if commands should be returned
     */
    constructor({ deviceId, networkIds, deviceTypeIds, names, returnCommands = true, returnUpdatedCommands = false, returnNotifications = false } = {}) {
        super();
        this.deviceId = deviceId;
        this.networkIds = networkIds;
        this.deviceTypeIds = deviceTypeIds;
        this.names = names;
        this.returnCommands = returnCommands;
        this.returnUpdatedCommands = returnUpdatedCommands;
        this.returnNotifications = returnNotifications;
    }

    get deviceId() {
        return this._deviceId;
    }

    set deviceId(value) {
        this._deviceId = value;
    }

    get networkIds() {
        return this._networkIds;
    }

    set networkIds(value) {
        this._networkIds = value;
    }

    get deviceTypeIds() {
        return this._deviceTypeIds;
    }

    set deviceTypeIds(value) {
        this._deviceTypeIds = value;
    }

    get names() {
        return this._names;
    }

    set names(value) {
        this._names = value;
    }

    get returnCommands() {
        return this._returnCommands;
    }

    set returnCommands(value) {
        this._returnCommands = value;
    }

    get returnUpdatedCommands() {
        return this._returnUpdatedCommands;
    }

    set returnUpdatedCommands(value) {
        this._returnUpdatedCommands = value;
    }

    get returnNotifications() {
        return this._returnNotifications;
    }

    set returnNotifications(value) {
        this._returnNotifications = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            deviceId: this.deviceId,
            networkIds: this.networkIds,
            deviceTypeIds: this.deviceTypeIds,
            names: this.names,
            returnCommands: this.returnCommands,
            returnUpdatedCommands: this.returnUpdatedCommands,
            returnNotifications: this.returnNotifications
        };
    }
}

module.exports = PluginRegisterQuery;

},{"../BaseModel":43}],73:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * PluginUpdateQuery class
 */
class PluginUpdateQuery extends BaseModel {

    /**
     * Creates Plugin Update Query model
     * @param {object} options - Options for instance
     * @param {string} options.topicName - Name of topic that was created for the plugin
     * @param {string} [options.deviceId] - Device device_id
     * @param {string} [options.networkIds] - Network ids
     * @param {string} [options.deviceTypeIds] - Device type ids
     * @param {string} [options.names] - Command/Notification names
     * @param {boolean} [options.returnCommands] - Checks if commands should be returned
     * @param {boolean} [options.returnUpdatedCommands] - Checks if updated commands should be returned
     * @param {boolean} [options.returnNotifications] - Checks if commands should be returned
     * @param {string} [options.status] - Plugin status - active or disabled (ACTIVE | DISABLED | CREATED)
     * @param {string} [options.name] - Plugin name
     * @param {string} [options.description] - Plugin description
     * @param {string} [options.parameters] - Plugin parameters
     */
    constructor({ topicName, deviceId, networkIds, deviceTypeIds, names, returnCommands, returnUpdatedCommands,
        returnNotifications, status, name, description, parameters } = {}) {
        super();

        this.topicName = topicName;
        this.deviceId = deviceId;
        this.networkIds = networkIds;
        this.deviceTypeIds = deviceTypeIds;
        this.names = names;
        this.returnCommands = returnCommands;
        this.returnUpdatedCommands = returnUpdatedCommands;
        this.returnNotifications = returnNotifications;
        this.status = status;
        this.name = name;
        this.description = description;
        this.parameters = parameters;
    }

    get topicName() {
        return this._topicName;
    }

    set topicName(value) {
        this._topicName = value;
    }

    get deviceId() {
        return this._deviceId;
    }

    set deviceId(value) {
        this._deviceId = value;
    }

    get networkIds() {
        return this._networkIds;
    }

    set networkIds(value) {
        this._networkIds = value;
    }

    get deviceTypeIds() {
        return this._deviceTypeIds;
    }

    set deviceTypeIds(value) {
        this._deviceTypeIds = value;
    }

    get names() {
        return this._names;
    }

    set names(value) {
        this._names = value;
    }

    get returnCommands() {
        return this._returnCommands;
    }

    set returnCommands(value) {
        this._returnCommands = value;
    }

    get returnUpdatedCommands() {
        return this._returnUpdatedCommands;
    }

    set returnUpdatedCommands(value) {
        this._returnUpdatedCommands = value;
    }

    get returnNotifications() {
        return this._returnNotifications;
    }

    set returnNotifications(value) {
        this._returnNotifications = value;
    }

    get status() {
        return this._status;
    }

    set status(value) {
        this._status = value;
    }

    get name() {
        return this._name;
    }

    set name(value) {
        this._name = value;
    }

    get description() {
        return this._description;
    }

    set description(value) {
        this._description = value;
    }

    get parameters() {
        return this._parameters;
    }

    set parameters(value) {
        this._parameters = value;
    }

    /**
     *
     * @returns {{topicName: string, deviceId: string, networkIds: string, deviceTypeIds: string, names: string, returnCommands: boolean, returnUpdatedCommands: boolean, returnNotifications: boolean, status: string,name: string, description: string, parameters: string }}
     */
    toObject() {
        return {
            topicName: this.topicName,
            deviceId: this.deviceId,
            networkIds: this.networkIds,
            deviceTypeIds: this.deviceTypeIds,
            names: this.names,
            returnCommands: this.returnCommands,
            returnUpdatedCommands: this.returnUpdatedCommands,
            returnNotifications: this.returnNotifications,
            status: this.status,
            name: this.name,
            description: this.description,
            parameters: this.parameters
        };
    }
}

module.exports = PluginUpdateQuery;

},{"../BaseModel":43}],74:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * UserCountQuery class
 */
class UserCountQuery extends BaseModel {

    /**
     * Creates User Count Query
     * @param {object} options - Options for instance
     * @param {string} options.login - Filter by user login
     * @param {string} options.loginPattern - Filter by user login pattern
     * @param {number} options.role - Filter by user login patter
     * @param {number} options.status - Filter by user status. 0 is Active, 1 is Locked Out, 2 is Disabled
     * 
     */
    constructor({ login, loginPattern, role, status } = {}) {
        super();

        this.login = login;
        this.loginPattern = loginPattern;
        this.role = role;
        this.status = status;
    }

    get login() {
        return this._login;
    }

    set login(value) {
        this._login = value;
    }

    get loginPattern() {
        return this._loginPattern;
    }

    set loginPattern(value) {
        this._loginPattern = value;
    }

    get role() {
        return this._role;
    }

    set role(value) {
        this._role = value;
    }

    get status() {
        return this._status;
    }

    set status(value) {
        this._status = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            login: this.login,
            loginPattern: this.loginPattern,
            role: this.role,
            status: this.status
        };
    }
}

module.exports = UserCountQuery;

},{"../BaseModel":43}],75:[function(require,module,exports){
const BaseModel = require(`../BaseModel`);

/**
 * UserListQuery class
 */
class UserListQuery extends BaseModel {

    /**
     * Creates User List Query
     * @param {object} options - Options for instance
     * @param {string} options.login - Filter by user login
     * @param {string} options.loginPattern - Filter by user login pattern
     * @param {number} options.role - Filter by user login patter
     * @param {number} options.status - Filter by user status. 0 is Active, 1 is Locked Out, 2 is Disabled
     * @param {string} options.sortField - Result list sort field
     * @param {string} options.sortOrder - Result list sort order. The sortField should be specified
     * @param {number} options.take - Number of records to take from the result list
     * @param {number} options.skip - Number of records to skip from the result list
     */
    constructor({ login, loginPattern, role, status, sortField, sortOrder, take, skip } = {}) {
        super();

        this.login = login;
        this.loginPattern = loginPattern;
        this.role = role;
        this.status = status;
        this.sortField = sortField;
        this.sortOrder = sortOrder;
        this.take = take;
        this.skip = skip;
    }

    get login() {
        return this._login;
    }

    set login(value) {
        this._login = value;
    }

    get loginPattern() {
        return this._loginPattern;
    }

    set loginPattern(value) {
        this._loginPattern = value;
    }

    get role() {
        return this._role;
    }

    set role(value) {
        this._role = value;
    }

    get status() {
        return this._status;
    }

    set status(value) {
        this._status = value;
    }

    get sortField() {
        return this._sortField;
    }

    set sortField(value) {
        this._sortField = value;
    }

    get sortOrder() {
        return this._sortOrder;
    }

    set sortOrder(value) {
        this._sortOrder = value;
    }

    get take() {
        return this._take;
    }

    set take(value) {
        this._take = value;
    }

    get skip() {
        return this._skip;
    }

    set skip(value) {
        this._skip = value;
    }

    /**
     * Returns instance as a plain JS object
     * @returns {Object}
     */
    toObject() {
        return {
            login: this.login,
            loginPattern: this.loginPattern,
            role: this.role,
            status: this.status,
            sortField: this.sortField,
            sortOrder: this.sortOrder,
            take: this.take,
            skip: this.skip
        };
    }
}

module.exports = UserListQuery;

},{"../BaseModel":43}],76:[function(require,module,exports){
require('isomorphic-fetch');
const Transport = require(`./base/Transport`);
const Utils = require('../utils/Utils');
const ReconnectionAttemptFailedError = require('../error/ReconnectionAttemptFailedError');
const { URL } = require(`url`);

/**
 * HTTP Transport class
 * @event open
 * @event message
 * @event error
 * @event reconnected
 */
class HTTP extends Transport {

    static get TYPE() {
        return `http`;
    }
    static get GET_METHOD() {
        return `GET`;
    }

    /**
     * Creates HTTP
     */
    constructor() {
        super();

        const me = this;

        me.type = HTTP.TYPE;
        me.token = ``;
        me.subscriptionMap = new Map();
        me.reconnectionIntervalHandler = null;
        me.pingUrl = ``;
        me.pingMethod = ``;
    }

    /**
     * Connect HTTP transport
     */
    connect() {
        const me = this;

        return new Promise(resolve => {
            me._ping().then(resolve).catch(() => me._startReconnection());
        });
    }

    /**
     * Authenticate transport
     * @param {string} token - Auth token
     */
    authenticate(token) {
        const me = this;

        me.token = token;

        return Promise.resolve();
    }

    /**
     * HTTP transport send method
     * @param endpoint
     * @param method
     * @param body
     * @param subscription
     * @param unsubscription
     * @param noAuth
     * @param polling
     * @returns {*}
     */
    send({ endpoint, method, body, subscription, unsubscription, noAuth, polling = false }) {
        const me = this;

        if (subscription === true) {
            const subscriptionId = Utils.randomString();
            const longPollingHandler = me._initLongPolling(subscriptionId, endpoint, method, body);

            longPollingHandler.poll();

            me.subscriptionMap.set(subscriptionId, longPollingHandler);

            return Promise.resolve({ subscriptionId: subscriptionId });
        } else if (unsubscription === true) {
            const subscriptionId = body.subscriptionId;
            const longPollingHandler = me.subscriptionMap.get(subscriptionId);

            if (longPollingHandler) {
                longPollingHandler.stop();
                me.subscriptionMap.delete(subscriptionId);

                return Promise.resolve({ status: `success` });
            } else {
                return Promise.resolve({ status: `No such subscription` });
            }
        } else {
            return fetch(endpoint, { headers: me._getHeaders(noAuth), method: method, body: JSON.stringify(body) }).then(response => response.text()).then(responseText => responseText ? JSON.parse(responseText) : responseText).catch(error => {
                if (!polling) {
                    throw error;
                } else {
                    return me._ping().catch(() => me._startReconnection());
                }
            });
        }
    }

    /**
     * Disconnects HTTP transport
     */
    disconnect() {
        const me = this;

        me._stopAllPolling();

        me.token = ``;
    }

    /**
     * Initialize http sever ping parameters
     * @param pingUrl
     * @param pingMethod
     */
    initPingParameters(pingUrl, pingMethod) {
        const me = this;

        me.pingUrl = pingUrl;
        me.pingMethod = pingMethod;
    }

    /**
     * Ping server
     * @returns {Promise<Response>}
     * @private
     */
    _ping() {
        const me = this;

        return fetch(me.pingUrl, { headers: me._getHeaders(true), method: me.pingMethod });
    }

    /**
     * Initialize polling functionality
     * @param subscriptionId
     * @param endpoint
     * @param method
     * @param body
     * @returns {{poll: poll, stop: stop}}
     */
    _initLongPolling(subscriptionId, endpoint, method, body) {
        const me = this;
        let stopped = false;
        const parsedEndpoint = new URL(endpoint);

        /**
         * Poll notifications
         */
        function poll() {
            me.send({ endpoint: parsedEndpoint.href, method, body, polling: true }).then(messageList => {
                if (!stopped) {
                    if (messageList && messageList.length) {
                        let latestTimestamp;

                        messageList.forEach(message => {
                            message.subscriptionId = subscriptionId;
                            me.emit(Transport.MESSAGE_EVENT, message);

                            latestTimestamp = Utils.getLatestTimestamp(message.timestamp, latestTimestamp);
                        });

                        if (latestTimestamp) {
                            parsedEndpoint.searchParams.set(`timestamp`, latestTimestamp);
                        }
                    }

                    poll();
                }
            }).catch(error => me.emit(Transport.ERROR_EVENT, error));
        }

        /**
         * Stop polling
         */
        function stop() {
            stopped = true;
        }

        return { poll, stop };
    }

    /**
     * Reconnection routine
     * @private
     */
    _startReconnection() {
        const me = this;
        let successfulPinged = false;
        let reconnectionCounter = 0;

        me._stopAllPolling();

        me.reconnectionIntervalHandler = setInterval(() => {
            me._ping().then(() => {
                if (!successfulPinged) {
                    successfulPinged = true;
                    clearInterval(me.reconnectionIntervalHandler);

                    me.emit(Transport.RECONNECTED_EVENT);
                }
            }).catch(() => {
                if (!successfulPinged) {
                    reconnectionCounter++;

                    if (reconnectionCounter === me.reconnectionAttempts) {
                        clearInterval(me.reconnectionIntervalHandler);
                    }

                    me.emit(Transport.ERROR_EVENT, new ReconnectionAttemptFailedError(reconnectionCounter));
                }
            });
        }, me.reconnectionInterval);
    }

    /**
     * Stop all polling handlers
     * @private
     */
    _stopAllPolling() {
        const me = this;

        me.subscriptionMap.forEach(pollingHandler => pollingHandler.stop());
        me.subscriptionMap.clear();
    }

    /**
     * Returns request headers
     * @param noAuth
     * @returns {Object}
     * @private
     */
    _getHeaders(noAuth = false) {
        const me = this;
        const headers = {
            "Content-type": `application/json`,
            "Accept": `application/json`
        };

        if (me.token && !noAuth) {
            headers.Authorization = `Bearer ${me.token}`;
        }

        return headers;
    }
}

module.exports = HTTP;

},{"../error/ReconnectionAttemptFailedError":39,"../utils/Utils":79,"./base/Transport":78,"isomorphic-fetch":4,"url":17}],77:[function(require,module,exports){
const Transport = require(`./base/Transport`);
const Utils = require('../utils/Utils');
const WebSocket = require('universal-websocket-client');
const WebSocketError = require('../error/WebSocketError');
const ReconnectionAttemptFailedError = require('../error/ReconnectionAttemptFailedError');

/**
 * WebSocket Transport class
 * @event open
 * @event message
 * @event error
 * @event reconnected
 */
class WS extends Transport {

    static get TYPE() {
        return `ws`;
    }

    static get OPEN_EVENT() {
        return `open`;
    }
    static get MESSAGE_EVENT() {
        return `message`;
    }
    static get ERROR_EVENT() {
        return `error`;
    }
    static get CLOSE_EVENT() {
        return `close`;
    }

    static get ERROR_CONNECTION_RESET_CODE() {
        return `ECONNRESET`;
    }
    static get ERROR_CONNECTION_REFUSED_CODE() {
        return `ECONNREFUSED`;
    }

    /**
     * Creates WS
     * @param {String} url - WebSocket URL
     */
    constructor({ url } = {}) {
        super();

        const me = this;

        me.type = WS.TYPE;
        me.url = url;
        me.isOpend = false;
        me.isReconnecting = false;
        me.reconnectionCounter = 0;
    }

    /**
     * Connect WebSocket transport
     * @returns {Promise<any>}
     */
    connect() {
        const me = this;

        return new Promise(resolve => {
            me.once(Transport.OPEN_EVENT, resolve);
            me._open();
        });
    }

    /**
     * Authenticate transport
     * @param {String} token - Auth token
     * @returns {*}
     */
    authenticate(token) {
        const me = this;

        return me.send({ action: `authenticate`, token: token });
    }

    /**
     * WebSocket API send method
     */
    send(params) {
        const me = this;

        return me._getSocket().then(() => {
            const { requestId = Utils.randomString() } = params;

            params.requestId = requestId;

            return new Promise(resolve => {
                me.socket.send(JSON.stringify(params));

                const listener = messageData => {
                    if (messageData.requestId === requestId) {
                        me.removeListener(params.requestId, listener);

                        resolve(messageData);
                    }
                };

                me.addListener(params.requestId, listener);
            });
        });
    }

    /**
     * Disconnects WS transport
     */
    disconnect() {
        const me = this;

        me.socket.close();
    }

    /**
     * Opens WS connection
     * @private
     */
    _open() {
        const me = this;

        me.socket = new WebSocket(me.url);

        me.socket.addEventListener(WS.MESSAGE_EVENT, event => {
            try {
                const messageData = JSON.parse(event.data);

                if (messageData.requestId) {
                    me.emit(messageData.requestId, messageData);
                } else {
                    me.emit(Transport.MESSAGE_EVENT, messageData);
                }
            } catch (error) {
                console.warn(error);
            }
        });

        me.socket.addEventListener(WS.ERROR_EVENT, error => {
            me.isReconnecting = false;

            switch (error.code) {
                case WS.ERROR_CONNECTION_RESET_CODE:
                case WS.ERROR_CONNECTION_REFUSED_CODE:
                    me._reconnect();
                    break;
                default:
                    me.emit(Transport.ERROR_EVENT, new WebSocketError(error));
                    break;
            }
        });

        me.socket.addEventListener(WS.OPEN_EVENT, () => {
            me.isOpend = true;
            me.reconnectionCounter = 0;

            if (me.isReconnecting === true) {
                me.isReconnecting = false;

                me.emit(Transport.RECONNECTED_EVENT);
            } else {
                me.emit(Transport.OPEN_EVENT);
            }
        });

        me.socket.addEventListener(WS.CLOSE_EVENT, () => me.isOpend = false);
    }

    /**
     * Gettting socket according to if it opened
     * @returns {Promise} when socket opened
     */
    _getSocket() {
        const me = this;

        return new Promise((resolve, reject) => {
            if (me.isOpend === true) {
                resolve(me.socket);
            } else if (me.isReconnecting === true) {
                reject(new Error(`WebSocket is reconnecting`));
            } else {
                me.socket.addEventListener(WS.OPEN_EVENT, () => {
                    me.isOpend = true;
                    resolve(me.socket);
                });
            }
        });
    }

    /**
     * Reconnection routine
     * @private
     */
    _reconnect() {
        const me = this;

        if (me.reconnectionCounter) {
            me.emit(Transport.ERROR_EVENT, new ReconnectionAttemptFailedError(me.reconnectionCounter));
        }

        me.isOpend = false;
        me.isReconnecting = true;
        me.socket.removeAllListeners();

        if (me.reconnectionCounter !== me.reconnectionAttempts) {
            setTimeout(() => me._open(), me.reconnectionInterval);
        }

        me.reconnectionCounter++;
    }
}

module.exports = WS;

},{"../error/ReconnectionAttemptFailedError":39,"../error/WebSocketError":42,"../utils/Utils":79,"./base/Transport":78,"universal-websocket-client":16}],78:[function(require,module,exports){
const EventEmitter = require('events');
const Utils = require(`../../utils/Utils`);

/**
 * Base Transport class
 * @event open
 * @event message
 * @event error
 * @event reconnected
 */
class Transport extends EventEmitter {

    static get OPEN_EVENT() {
        return `open`;
    }
    static get MESSAGE_EVENT() {
        return `message`;
    }
    static get ERROR_EVENT() {
        return `error`;
    }
    static get RECONNECTED_EVENT() {
        return `reconnected`;
    }

    static get INFINITY_RECONNECTION() {
        return -1;
    }
    static get RECONNECTION_TIMEOUT_MS() {
        return 5000;
    }

    get reconnectionAttempts() {
        return this._reconnectionAttempts;
    }

    set reconnectionAttempts(value) {
        this._reconnectionAttempts = Utils.isDefined(value) ? value : Transport.INFINITY_RECONNECTION;
    }

    get reconnectionInterval() {
        return this._reconnectionInterval;
    }

    set reconnectionInterval(value) {
        this._reconnectionInterval = Utils.isDefined(value) ? value : Transport.RECONNECTION_TIMEOUT_MS;
    }

    /**
     * Connect transport
     */
    connect() {
        console.warn(`Method "connect" should be implemented in nested classes`);
    }

    /**
     * Authenticate transport with token
     * @param token
     */
    authenticate(token) {
        console.warn(`Method "authenticate" should be implemented in nested classes`);
    }

    /**
     * Send message via transport
     */
    send() {
        console.warn(`Method "send" should be implemented in nested classes`);
    }

    /**
     * Disconnects transport
     */
    disconnect() {
        console.warn(`Method "disconnect" should be implemented in nested classes`);
    }
}

module.exports = Transport;

},{"../../utils/Utils":79,"events":3}],79:[function(require,module,exports){
const jwtDecode = require(`jwt-decode`);
const UserToken = require(`../models/UserToken`);

/**
 * Utils
 */
class Utils {

    static get TOKEN_EXPIRED_MARK() {
        return `Token expired`;
    }

    /**
     * Checks that object is empty
     * @returns {boolean} - Is object empty
     */
    static isObjectEmpty(obj) {
        return obj && obj.constructor === Object && Object.keys(obj).length === 0;
    }

    /**
     * Returns a twenty-character random string
     * @return {string} - Twenty-character random string
     */
    static randomString() {
        const firstPart = Math.random().toString(36).substring(2, 15);
        const secondPart = Math.random().toString(36).substring(2, 15);

        return `${firstPart}${secondPart}`;
    }

    /**
     * Creates UserToken from jwt
     * @param jwtToken
     * @returns {UserToken}
     */
    static createUserTokenFromJWT(jwtToken) {
        const tokenPayload = jwtDecode(jwtToken).payload;

        return new UserToken({
            userId: tokenPayload.u,
            actions: tokenPayload.a,
            networkIds: tokenPayload.n,
            deviceTypeIds: tokenPayload.dt
        });
    }

    /**
     * Checks for value is not undefined and not null
     * @param value
     * @returns {boolean}
     */
    static isDefined(value) {
        return !(typeof value === 'undefined' || value === null);
    }

    /**
     * Empty function
     */
    static emptyFn() {}

    /**
     * Returns latest timestamp
     * @param ts1
     * @param ts2
     * @returns {*}
     */
    static getLatestTimestamp(ts1, ts2) {
        if (!ts1) {
            return ts2;
        } else if (!ts2) {
            return ts1;
        }

        return new Date(ts1).getTime() > new Date(ts2).getTime() ? ts1 : ts2;
    }
}

module.exports = Utils;

},{"../models/UserToken":53,"jwt-decode":7}]},{},[1])
//# sourceMappingURL=devicehive.js.map
